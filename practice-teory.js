let list = [
    {
        "title": "Маячок",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Маячок</h1><a href='https://youtu.be/vFpTqXtd43k?si=rr1vuxSHutO7Bi60' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/FM4TPt93Vp0?si=g02YlKYWQUB35db6' class='linkk'>Видео для помощи 2</a><a href='https://youtu.be/C4OJ6jFaTKE?si=AAex7NnNzB2ASIKl' class='linkk'>Видео для помощи 3</a><p class='simple-text'>Мигание светодиодом на Arduino – первое, что делают на этой платформе начинающие ардуинщики. Проекты, связанные со светодиодами – самые популярные уроки, с которых начинается большинство учебников. </p><h1 class='small-topic-2'>Что мы узнаем:</h1><p class='simple-text'>Как подключить светодиод к ардуино.</p><p class='simple-text'>Повторим процедуру загрузки скетча в микроконтроллер</p><h1 class='small-topic-2'>Алгоритм программы очень прост.</h1><p class='simple-text'>1. Мы должны подать напряжение на светодиод (на тот пин, к которому подсоединен светодиод, в нашем случае, 13).</p><p class='simple-text'>2. Затем ждем некоторое время. Например, секунду.</p><p class='simple-text'>3. После чего убираем напряжение.</p><p class='simple-text'>4. И опять немного ждем, чтобы глаз мог заметить, что света нет.</p><p class='simple-text'>5. Начинаем все с первого пункта</p><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>2 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k1.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k2.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><p class='simple-text'>Не забудьте, как соединены рельсы в беспаечной макетной плате. Если на вашей макетке красная и синяя линии вдоль длинных рельс прерываются в середине, значит проводник внутри макетки тоже прерывается!</p><p class='simple-text'>Катод («минус») светодиода — короткая ножка, именно её нужно соединять с землёй (GND)</p><p class='simple-text'>Не пренебрегайте резистором, иначе светодиод выйдет из строя</p><p class='simple-text'>Выбрать резистор нужного номинала можно с помощью таблицы маркировки или с помощью мультиметра в режиме измерения сопротивления</p><p class='simple-text'>Плата Arduino имеет три пина GND, используйте любой из них</p><h1 class='small-topic-2'>Выполняем действия по шагам – в результате обязательно получим результат.</h1><p class='simple-text'>1. Берем плату Arduino UNO. Убеждаемся, что на ней есть встроенный светодиод.</p><p class='simple-text'>2. Подключаем плату Arduino к компьютеру через USB-кабель. В результате должны загореться лампочки.</p><p class='simple-text'>3. Открываем на компьютере программу Arduino IDE (вы уже должны знать, как это делается или прочитайте статьи на нашем сайте по ссылкам выше).</p><p class='simple-text'>4. Проверяем, что ардуино подключился: найдите в меню «Инструменты», подменю «Порт». Оно должно быть активным. Нажмите на этот пункт и посмотрите список портов. Один из них должен быть отмечен галочкой. Если этого не произошло, выберите порт с самым большим номером и отметьте его. Если это не помогло – смотрите раздел с описанием типичных проблем чуть ниже.</p><img src='img/k3.png' alt='sheme' class='sheme'><p class='simple-text'>1. Проверка порта Ардуино</p><p class='simple-text'>2. Открываем меню Файл. В нем находим подменю «Примеры», и в нем подменю Basics. Находим в открывшемся списке меню строчку Blink и нажимаем на нее. Должно открыться отдельное окно Arduino с текстом программы (в самом верху будет серый текст).</p><img src='img/k4.png' alt='sheme' class='sheme'><p class='simple-text'>1. Найдите в меню кнопку “загрузить скетч” (со стрелочкой) и нажмите ее. Начнется процесс проверки (компиляции) скетча и загрузки в плату.</p><p class='simple-text'>2. После того, как скетч загружен и в статусном окне внизу появится надпись «Загрузка завершена», можно проверять результат. Посмотрите на плату – вы должны увидеть мигающий огонек. Значит, мы сделали это!</p><p class='simple-text'>3. Проверьте, что программа работает как надо – замерьте паузы между включением и выключением.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k5.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Процедура setup выполняется один раз при запуске микроконтроллера. Обычно она используется для конфигурации портов микроконтроллера и других настроек</p><p class='simple-text'>После выполнения setup запускается процедура loop, которая выполняется в бесконечном цикле. Именно этим мы пользуемся в данном примере, чтобы маячок мигал постоянно</p><p class='simple-text'>Процедуры setup и loop должны присутствовать в любой программе (скетче), даже если вам не нужно ничего выполнять в них — пусть они будут пустые, просто не пишите ничего между фигурными скобками. Например:</p><img src='img/k6.png' alt='sheme' class='sheme'><p class='simple-text pad-bot'>Запомните, что каждой открывающей фигурной скобке { всегда соответствует закрывающая }. Они обозначают границы некого логически завершенного фрагмента кода. Следите за вложенностью фигурных скобок. Для этого удобно после каждой открывающей скобки увеличивать отступ на каждой новой строке на один символ табуляции (клавиша Tab)</p><p class='simple-text'>Обращайте внимание на ; в концах строк. Не стирайте их там, где они есть, и не добавляйте лишних. Вскоре вы будете понимать, где они нужны, а где нет.</p><p class='simple-text'>Функция digitalWrite(pin, value) не возвращает никакого значения и принимает два параметра:</p><p class='simple-text'>	 pin — номер цифрового порта, на который мы отправляем сигнал</p><p class='simple-text'>	 value — значение, которое мы отправляем на порт. Для цифровых портов значением может быть HIGH (высокое, единица) или LOW (низкое, ноль)</p><p class='simple-text'>Если в качестве второго параметра вы передадите функции digitalWrite значение, отличное от HIGH, LOW, 1 или 0, компилятор может не выдать ошибку, но считать, что передано HIGH. Будьте внимательны</p><p class='simple-text pad-bot'>Обратите внимание, что использованные нами константы: INPUT, OUTPUT, LOW, HIGH, пишутся заглавными буквами, иначе компилятор их не распознает и выдаст ошибку. Когда ключевое слово распознано, оно подсвечивается синим цветом в Arduino IDE</p></aside>"
    },
    {
        "title": "Эксперимент 2. Маячок с нарастающей яркостью",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Принципиальные схемы</h1><a href='https://youtu.be/ZikhME7ZL0o?si=407-n74Zgk08vmGM' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/ZikhME7ZL0o?si=407-n74Zgk08vmGM' class='linkk'>Видео для помощи 2</a><a href='https://youtu.be/ZikhME7ZL0o?si=407-n74Zgk08vmGM' class='linkk'>Видео для помощи 3</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>2 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k7.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k8.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Скетч</h1><img src='img/k9.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Идентификаторы переменных, констант, функций (в этом примере идентификатор LED_PIN) являются одним словом (т.е. нельзя создать идентификатор LED PIN).</p><p class='simple-text'>Идентификаторы могут состоять из латинских букв, цифр и символов подчеркивания _. При этом идентификатор не может начинаться с цифры.</p><img src='img/k10.png' alt='sheme' class='sheme'><p class='simple-text'>Регистр букв в идентификаторе имеет значение. Т.е. LED_PIN, LED_pin и led_pin с точки зрения компилятора — различные идентификаторы</p><p class='simple-text'>Идентификаторы, создаваемые пользователем, не должны совпадать с предопределенными идентификаторами и стандартными конструкциями языка; если среда разработки подсветила введенный идентификтор каким-либо цветом, замените его на другой</p><p class='simple-text'>Директива #define просто говорит компилятору заменить все вхождения заданного идентификатора на значение, заданное после пробела (здесь 9), эти директивы помещают в начало кода. В конце данной директивы точка с запятой ; не допустима</p><p class='simple-text'>Названия идентификаторов всегда нужно делать осмысленными, чтобы при возвращении к ранее написанному коду вам было ясно, зачем нужен каждый из них</p><p class='simple-text'>Также полезно снабжать код программы комментариями: в примерах мы видим однострочные комментарии, которые начинаются с двух прямых слэшей // и многострочные, заключённые между /* </p><img src='img/k11.png' alt='sheme' class='sheme'><p class='simple-text'>комментарии игнорируются компилятором, зато полезны людям при чтении давно написанного, а особенно чужого, кода</p><p class='simple-text'>Функция analogWrite(pin, value) не возвращает никакого значения и принимает два параметра:</p><p class='simple-text'>  pin — номер порта, на который мы отправляем сигнал</p><p class='simple-text pad-bot'>  value — значение скважности ШИМ, которое мы отправляем на порт. Он может принимать целочисленное значение от 0 до 255, где 0 — это 0%, а 255 — это 100%</p></aside>"
    },
    {
        "title": "Эксперимент 3. Светильник с управляемой яркостью",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 3. Светильник с управляемой яркостью</h1><a href='https://youtu.be/dUJgVg-u3Ds?si=864PfVmUEApMRRWq' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>6 проводов «папа-папа»</p><p class='simple-text'>1 потенциометр</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k12.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k13.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Мы подключили «землю» светодиода и переменного резистора (потенциометра) к длинной рельсе «-» макетной платы, и уже ее соединили с входом GND микроконтроллера. Таким образом мы использовали меньше входов и от макетки к контроллеру тянется меньше проводов.</p><p class='simple-text'>Подписи «+» и «-» на макетке не обязывают вас использовать их строго для питания, просто чаще всего они используются именно так и маркировка нам помогает</p><p class='simple-text'>Не важно, какая из крайних ножек потенциометра будет подключена к 5 В, а какая к GND, поменяется только направление, в котором нужно крутить ручку для увеличения напряжения. Запомните, что сигнал мы считываем со средней ножки</p><p class='simple-text'>Для считывания аналогового сигнала, принимающего широкий спектр значений, а не просто 0 или 1, как цифровой, подходят только порты, помеченные на плате как «ANALOG IN» и пронумерованные с префиксом A. Для Arduino Uno — это A0-A5.</p><img src='img/k14.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>С помощью директивы #define мы сказали компилятору заменять идентификатор POT_PIN на A0 — номер аналогового входа. Вы можете встретить код, где обращение к аналоговому порту будет по номеру без индекса A. Такой код будет работать, но во избежание путаницы с цифровыми портами используйте индекс.</p><p class='simple-text'>Переменным принято давать названия, начинающиеся со строчной буквы.</p><p class='simple-text'>Чтобы использовать переменную, необходимо ее объявить, что мы и делаем инструкцией:</p><img src='img/k15.png' alt='sheme' class='sheme'><p class='simple-text'>Для объявления переменной необходимо указать ее тип, здесь — int (от англ. integer) — целочисленное значение в диапазоне от -32 768 до 32 767, с другими типами мы познакомимся позднее</p><p class='simple-text'>Переменные одного типа можно объявить в одной инструкции, перечислив их через запятую, что мы и сделали</p><p class='simple-text'>Функция analogRead(pinA) возвращает целочисленное значение в диапазоне от 0 до 1023, пропорциональное напряжению, поданному на аналоговый вход, номер которого мы передаем функции в качестве параметра pinA</p><p class='simple-text pad-bot'>Обратите внимание, как мы получили значение, возвращенное функцией analogRead(): мы просто поместили его в переменную rotation с помощью оператора присваивания =, который записывает то, что находится справа от него в ту переменную, которая стоит слева</p></aside>"
    },
    {
        "title": "Эксперимент 4. Терменвокс",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 4. Терменвокс</h1><a href='https://youtu.be/bTGZmzx3RNI?si=NrZpvgOUMyrdRwOu' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/iN_RuAC9k2o?si=oeSUe3X3b3_kty8H' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 пьезопищалка</p><p class='simple-text'>6 проводов «папа-папа»</p><p class='simple-text'>1 резистор номиналом 10 кОм</p><p class='simple-text'>1 фоторезистор</p><h1 class='small-topic-2'>Рисованная схема</h1><img src='img/k16.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><img src='img/k17.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><p class='simple-text'>В данной схеме мы используем резистор нового номинала, посмотрите таблицу маркировки, чтобы найти резистор на 10 кОм или воспользуйтесь мультиметром</p><p class='simple-text'>Полярность фоторезистора, как и обычного резистора, не играет роли. Его можно устанавливать любой стороной</p><p class='simple-text'>В данном упражнении мы собираем простой вариант схемы включения пьезодинамика</p><p class='simple-text'>Полярность пьезопищалки роли не играет: вы можете подключать любую из ее ножек к земле, любую к порту микроконтроллера</p><p class='simple-text'>На Arduino Uno использование функции tone мешает использованию ШИМ на 3-м и 11-м портах. Зато можно подключить ее к одному из них</p><p class='simple-text'>Вспомните как устроен делитель напряжения: фоторезистор помещается в позицию R2 — между аналоговым входом и землей. Так мы получаем резистивный фотосенсор.</p><img src='img/k18.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><p class='simple-text'>Функция map(value, fromLow, fromHigh, toLow, toHigh) возвращает целочисленное значение из интервала [toLow, toHigh], которое является пропорциональным отображением содержимого value из интервала [fromLow, fromHigh]</p><p class='simple-text'>Верхние границы map не обязательно должны быть больше нижних и могут быть отрицательными. К примеру, значение из интервала [1, 10] можно отобразить в интервал [10,-5]</p><p class='simple-text'>Если при вычислении значения map образуется дробное значение, оно будет отброшено, а не округлено</p><p class='simple-text'>Функция mapне будет отбрасывать значения за пределами указанных диапазонов, а также масштабирует их по заданному правилу.</p><p class='simple-text'>Если вам нужно ограничить множество допустимых значений, используйте функцию constrain(value, from, to), которая вернет:</p><p class='simple-text'>  value, если это значение попадает в диапазон [from, to]</p><p class='simple-text'>  from, если value меньше него</p><p class='simple-text'>  to, если value больше него</p><p class='simple-text'>Функция tone(pin, frequency, duration) заставляет пьезопищалку, подключенную к порту pin, издавать звук высотой frequency герц на протяжении duration миллисекунд</p><p class='simple-text'>Параметр duration не является обязательным. Если его не передать, звук включится навсегда. Чтобы его выключить, вам понадобится функция noTone(pin). Ей нужно передать номер порта с пищалкой, которую нужно выключить</p><p class='simple-text'>Одновременно можно управлять только одной пищалкой. Если во время звучания вызвать tone для другого порта, ничего не произойдет.</p><p class='simple-text pad-bot'>Вызов tone для уже звучащего порта обновит частоту и длительность звучан</p></aside>"
    },
    {
        "title": "Эксперимент 5. Ночной светильник",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 5. Ночной светильник</h1><a href='https://youtu.be/iN_RuAC9k2o?si=e7I4suAV_gq6yiaG' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/bTGZmzx3RNI?si=tmZL-4_qwQy9JmDT' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 фоторезистор</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>1 резистор номиналом 10 кОм</p><p class='simple-text'>1 переменный резистор (потенциометр)</p><p class='simple-text'>10 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k19.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k20.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>В этом эксперименте мы устанавливаем фоторезистор между питанием и аналоговым входом, т.е. в позицию R1 в схеме делителя напряжения. Это нам нужно для того, чтобы при уменьшении освещенности мы получали меньшее напряжение на аналоговом входе.</p><p class='simple-text'>Постарайтесь разместить компоненты так, чтобы светодиод не засвечивал фоторезистор.</p><img src='img/k21.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Мы используем новый тип переменных — boolean, которые хранят только значения true (истина, 1) или false (ложь, 0). Эти значения являются результатом вычисления логических выражений. В данном примере логическое выражение — это lightness < threshold. На человеческом языке это звучит как: «освещенность ниже порогового уровня». Такое высказывание будет истинным, когда освещенность ниже порогового уровня. Микроконтроллер может сравнить значения переменных lightness и threshold, которые, в свою очередь, являются результатами измерений, и вычислить истинность логического выражения.</p><p class='simple-text'>Мы взяли это логическое выражение в скобки только для наглядности. Всегда лучше писать читабельный код. В других случаях скобки могут влиять на порядок действий, как в обычной арифметике.</p><p class='simple-text'>В нашем эксперименте логическое выражение будет истинным, когда значение lightness меньше значения threshold, потому что мы использовали оператор <. Мы можем использовать операторы >, <=, >=, ==, !=, которые значат «больше», «меньше или равно», «больше или равно», «равно», «не равно» соответственно.</p><p class='simple-text'>Будьте особенно внимательны с логическим оператором == и не путайте его с оператором присваивания =. В первом случае мы сравниваем значения выражений и получаем логическое значение (истина или ложь), а во втором случае присваиваем левому операнду значение правого. Компилятор не знает наших намерений и ошибку не выдаст, а мы можем нечаянно изменить значение какой-нибудь переменной и затем долго разыскивать ошибку.</p><p class='simple-text'>Условный оператор if («если») — один из ключевых в большинстве языков программирования. С его помощью мы можем выполнять не только жестко заданную последовательность действий, но принимать решения, по какой ветви алгоритма идти, в зависимости от неких условий.</p><p class='simple-text'>У логического выражения lightness < threshold есть значение: true или false. Мы вычислили его и поместили в булеву переменную tooDark («слишком темно»). Таким образом мы как бы говорим «если слишком темно, то включить светодиод»</p><p class='simple-text'>С таким же успехом мы могли бы сказать «если освещенность меньше порогового уровня, то включить светодиод», т.е. передать в if всё логическое выражени</p><img src='img/k22.png' alt='sheme' class='sheme'><p class='simple-text'>За условным оператором if обязательно следует блок кода, который выполняется в случае истинности логического выражения. Не забывайте про обе фигурные скобки {}!</p><p class='simple-text'>Если в случае истинности выражения нам нужно выполнить только одну инструкцию, ее можно написать сразу после if (…) без фигурных скобок:</p><img src='img/k23.png' alt='sheme' class='sheme'><p class='simple-text pad-bot'>Оператор if может быть расширен конструкцией else («иначе»). Блок кода или единственная инструкция, следующий за ней, будет выполнен только если логическое выражение в if имеет значение false, «ложь». Правила, касающиеся фигурных скобок, такие же. В нашем эксперименте мы написали «если слишком темно, включить светодиод, иначе выключить светодиод».</p></aside>"
    },
    {
        "title": "Эксперимент 6. Пульсар",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 6. Пульсар</h1><a href='https://youtu.be/qS7V8hog2EA?si=NUtla7lUBBUG8D7n' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/JI-6VMlEVAk?si=aQJwrwN2xRLvNLa8' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 биполярный транзистор</p><p class='simple-text'>1 светодиодная шкала</p><p class='simple-text'>1 резистор номиналом 1 кОм</p><p class='simple-text'>10 резисторов номиналом 220 Ом</p><p class='simple-text'>13 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k24.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k25.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Светодиодная шкала — это несколько светодиодов в одном корпусе. Нам нужно чтобы питание шло к их анодам, а катоды направлялись к земле. Скорее всего на вашей шкале аноды находятся со стороны маркировки. Если шкала не светится, когда должна, попробуйте перевернуть ее.</p><p class='simple-text'>База биполярного транзистора — это его средняя ножка. Если повернуть транзистор плоской стороной к себе, ножками вниз, то левая ножка это коллектор, а правая — эмиттер.</p><p class='simple-text'>Если эту схему собрать без резистора между базой транзистора и портом Arduino, мы практически устроим короткое замыкание порта на землю. Рано или поздно это выведет из строя транзистор или ножку микроконтроллера.</p><p class='simple-text'>Зачем здесь вообще транзистор? Без него такое количество светодиодов будет потреблять больше тока, чем 40 мА, которые может себе позволить цифровой пин платы. Поэтому мы берем питание из порта 5V, рассчитанного на ток до 500 мА, а на цифровой порт ставим транзистор, чтобы с помощью малого тока управлять большим.</p><p class='simple-text'>В данном случае мы включили 10 светодиодов параллельно, каждый через отдельный резистор. Включать их через один резистор неправильно: даже светодиоды из одной партии имеют минимальный разброс вольт-амперных характеристик, вследствие чего они:</p><p class='simple-text'>  Светились бы с различной яркостью</p><p class='simple-text'>  Из-за минимальной разницы во времени включения, больший ток, прошедший через первый включившийся светодиод, мог бы вывести его из строя. И так по цепочке.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k26.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Как мы уже знаем, analogWrite(pin, value) в качестве value принимает значения от 0 до 255. Если передать значение из-за пределов этого диапазона, функция сработает, но в общем случае вы получите неожиданный результат.</p><p class='simple-text'>Оператор X % Y дает остаток от деления X на Y. Если X меньше Y, т.е. целая часть результата деления равна 0, оператор % будет возвращать X. Таким образом:</p><p class='simple-text'>  Пока brightness + 1 меньше 256, в brightness записывается значение brightness + 1</p><p class='simple-text'>  Как только brightness + 1 принимает значение 256, результатом (brightness + 1) % 256 становится 0 и на следующей итерации loop() всё начинается сначала.</p><p class='simple-text'>Оператор % работает только с целыми операндами.</p><p class='simple-text pad-bot'>В выражении (brightness + 1) % 256 скобки используются для назначения порядка действий. Операция % имеет больший приоритет, чем +, а сложение нам нужно выполнять раньше. С операциями умножения и деления оператор взятия остатка имеет одинаковый приоритет.</p></aside>"
    },
    {
        "title": "Эксперимент 7. Бегущий огонёк",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 7. Бегущий огонёк</h1><a href='https://youtu.be/YXeoJizFEbE?si=jLXvkRtbOSUiYS63' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиодная шкала</p><p class='simple-text'>10 резисторов номиналом 220 Ом</p><p class='simple-text'>11 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k27.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k28.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Обратите внимание, что в данном эксперименте резисторы установлены между катодами и землей в отличие от эксперимента пульсар.</p><p class='simple-text'>Мы подключаем светодиоды к цифровым портам, начиная с порта 2. Мы можем использовать порты 0 и 1, но они являются каналами передачи данных последовательного порта и для каждой перепрошивки платы придется отключать устройства, подключенные к ним.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k29.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>С помощью выражения for мы организуем цикл со счетчиком. В данном случае для настройки портов на выход. Чтобы сделать такой цикл, нужно:</p><p class='simple-text'>Инициализировать переменную-счетчик, присвоив ей первоначальное значение. В нашем случае: int pin = FIRST_LED_PIN</p><p class='simple-text'>Указать условие, до достижения которого будет повторяться цикл. В нашем случае: pin <= LAST_LED_PIN</p><p class='simple-text'>Определить правило, по которому будет изменяться счетчик. В нашем случае ++pin (см. ниже об операторе ++).</p><p class='simple-text'>Например, можно сделать цикл for (int i = 10; i > 0; i = i - 1). В этом случае:</p><p class='simple-text'>Переменной i присваивается значение 10</p><p class='simple-text'>Это значение удовлетворяет условию i > 0</p><p class='simple-text'>Поэтому блок кода, помещенный в цикл, выполняется первый раз</p><p class='simple-text'>Значение i уменьшается на единицу, согласно заданному правилу, и принимает значение 9</p><p class='simple-text'>Блок кода выполняется второй раз.</p><p class='simple-text'>Всё повторяется снова и снова вплоть до значения i равного 0</p><p class='simple-text'>Когда i станет равна 0, условие i > 0 не выполнится, и выполнение цикла закончится</p><p class='simple-text'>Контроллер перейдет к коду, следующему за циклом for</p><p class='simple-text'>Помещайте код, который нужно зациклить, между парой фигурных скобок {}, если в нем больше одной инструкции.</p><p class='simple-text'>Переменная-счетчик, объявляемая в операторе for, может использоваться внутри цикла. Например, в данном эксперименте pin последовательно принимает значения от 2 до 11 и, будучи переданной в pinMode, позволяет настроить 10 портов одной строкой, помещенной в цикл.</p><p class='simple-text'>Переменные-счетчики видны только внутри цикла. Т.е. если обратиться к pin до или после цикла, компилятор выдаст ошибку о необъявленной переменной.</p><p class='simple-text'>Конструкция i = i - 1 в пояснении выше не является уравнением! Мы используем оператор присваивания = для того, чтобы в переменную i поместить значение, равное текущему значению i, уменьшенному на 1.</p><p class='simple-text'>Выражение ++pin — это т.н. оператор инкремента, примененный к переменной pin. Эта инструкция даст тот же результат, что pin = pin + 1</p><p class='simple-text'>Аналогично инкременту работает оператор декремента --, уменьшающий значение на единицу. Подробнее об этом в статье про арифметические операции.</p><p class='simple-text'>Тип данных unsigned int используют для хранения целых чисел без знака, т.е. только неотрицательных. За счет лишнего бита, который теперь не используется для хранения знака, мы можем хранить в переменной такого типа значения до 65 535.</p><p class='simple-text'>Функция millis возвращает количество миллисекунд, прошедших с момента включения или перезагрузки микроконтроллера. Здесь мы используем ее для отсчета времени между переключениями светодиодов.</p><p class='simple-text'>С помощью выражения (ms / 120) % 10 мы определяем, который из 10 светодиодов должен гореть сейчас. Перефразируя, мы определяем какой отрезок длиной в 120 мс идет сейчас и каков его номер внутри текущего десятка. Мы добавляем порядковый номер отрезка к номеру того порта, который в текущем наборе выступает первым.</p><p class='simple-text pad-bot'>То, что мы гасим светодиод с помощью digitalWrite(pin, LOW) всего через 10 мс после включения не заметно глазу, т.к. очень скоро будет вновь вычислено, какой из светодиодов включать, и он будет включен — только что погашенный или следующий.</p></aside>"
    },
    {
        "title": "Эксперимент 8. Мерзкое пианино",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 8. Мерзкое пианино</h1><a href='https://youtu.be/Y7D1tmlVVvk?si=CjZkxlqoSBMGL4aJ' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/ZRXytMr5tBs?si=kWRZMMzjM7RH9B7S' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 пьезопищалка</p><p class='simple-text'>3 тактовых кнопки</p><p class='simple-text'>3 резистора номиналом 10 кОм</p><p class='simple-text'>10 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k30.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k31.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Ножки тактовой кнопки, расположенные с одной стороны, разомкнуты, когда кнопка не нажата. Ножки, расположенные друг напротив друга на противоположных сторонах макетки находятся на одной «рельсе». Воспользовавшись этим, мы можем расположить резистор с одной стороны макетки, а провод, подключаемый к порту Arduino, с другой стороны.</p><p class='simple-text'>В данном эксперименте мы подключаем кнопки по схеме с подтягивающим резистором.</p><p class='simple-text'>Для того, чтобы данный вариант программы работал, важно, чтобы кнопки были подключены к портам, находящимся рядом друг с другом, т.е. имеющим соседние номера.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k32.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Благодаря тому, что в начале программы мы определили FIRST_KEY_PIN и KEY_COUNT, мы можем подключать произвольное количество кнопок к любым идущим друг за другом цифровым пинам, и для корректировки программы нам не придется менять параметры цикла for. Изменить понадобится лишь эти константы:</p><p class='simple-text'>цикл в любом случае пробегает от 0 до KEY_COUNT;</p><p class='simple-text'>перед считыванием порта мы задаем смещение на номер первого используемого порта — FIRST_KEY_PIN.</p><p class='simple-text'>Функция digitalRead(pin) возвращает состояние порта, номер которого передан ей параметром pin. Это может быть состояние HIGH или LOW. Или, выражаясь иначе: высокое напряжение или низкое, 1 или 0, true или false</p><p class='simple-text'>Поскольку мы получаем с порта одно из двух состояний, мы сохраняем его в переменную уже знакомого нам типа boolean, и можем работать с ней как с логическим значением.</p><p class='simple-text'>Мы используем логический оператор отрицания «не» !. Если keyUp имеет значение 0, выражение !keyUp будет иметь значение 1 и наоборот.</p><p class='simple-text'>Поскольку мы собрали схему с подтягивающим резистором, при нажатии кнопки мы будем получать на соответствующем порте 0.</p><p class='simple-text pad-bot'>Действия, описанные в условном выражении if, выполняются, когда его условие имеет значение «истина» (единица). Поэтому для выполнения действия по нажатию, мы инвертируем сигнал с кнопки.</p></aside>"
    },
    {
        "title": "Эксперимент 9. Миксер",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 9. Миксер</h1><a href='https://youtu.be/2H4m6myIDqw?si=D-OmgB7z9Loct2OV' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>беспаечная макетная плата</p><p class='simple-text'>3 тактовых кнопки</p><p class='simple-text'>1 коллекторный двигатель</p><p class='simple-text'>1 выпрямительный диод</p><p class='simple-text'>1 полевой MOSFET-транзистор</p><p class='simple-text'>15 проводов «папа-папа»</p><p class='simple-text'>1 клеммник, если вы используете мотор с проводами, которые плохо втыкаются в макетку</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k33.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k34.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Защитный диод нам нужен для того, чтобы ток обратного направления, который начнет создавать двигатель, вращаясь по инерции, не вывел из строя транзистор.</p><p class='simple-text'>Не перепутайте полярность диода, иначе, открыв транзистор, вы устроите короткое замыкание!</p><p class='simple-text'>Причину отсутствия подтягивающих/стягивающих резисторов в схеме вы поймете, ознакомившись с программой.</p><p class='simple-text'>Мы подключили питание схемы к выходу Vin платы микроконтроллера, потому что, в отличие выхода 5V, отсюда можно получить напряжение, подключенное к плате, без изменений и без ограничений по величине тока.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k35.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Мы использовали новый режим работы портов: INPUT_PULLUP. На цифровых портах Arduino есть встроенные подтягивающие резисторы, которые можно включить указанным образом одновременно с настройкой порта на вход. Именно поэтому мы не использовали резисторы при сборке схемы.</p><p class='simple-text pad-bot'>На каждой итерации цикла мы задаем мотору скорость вращения, пропорциональную текущему значению счетчика. Но выполнение инструкций не дойдет до назначения новой скорости, если при проверке нажатия кнопки она окажется отпущенной. Инструкция continue, которая выполнится в этом случае, отменит продолжение данной итерации цикла и выполнение программы продолжится со следующей. А мотор будет крутиться со скоростью, заданной при последнем нажатии на какую-то из кнопок.</p></aside>"
    },
    {
        "title": "Светодиод",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Светодиод</h1><p class='simple-text'><b>Светодиод</b> (англ. Light Emitting Diode или просто LED) — энергоэффективная, надёжная, долговечная «лампочка».</p><p class='simple-text'>Светодиод — вид диода, который светится, когда через него проходит ток от анода (+) к катоду (−).</p><p class='simple-text'>В настоящее время светодиоды нашли применение в самых различных областях: светодиодные фонари, автомобильная светотехника, рекламные вывески, светодиодные панели и индикаторы, бегущие строки и светофоры и т. д.</p><img src='img/схема38.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Основные характеристики</h1><img src='img/схема39.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Восприятие световых волн человеком</h1><img src='img/схема40.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Типовая схема включения</h1><img src='img/схема41.png' alt='sheme' class='sheme'><p class='simple-text'>Собственное сопротивление светодиода после насыщения очень мало, и без резистора, ограничивающего ток через светодиод, он перегорит.</p><p class='simple-text'>Порядок «резистор до» или «резистор после» — не важен.</p><h1 class='small-topic-2'>Поиск подходящего резистора</h1><p class='simple-text'>Рассчитаем какой резистор R в приведённой схеме нам нужно взять, чтобы получить оптимальный результат. Предположим, что у нас такой светодиод и источник питания:</p><img src='img/схема42.png' alt='sheme' class='sheme'><p class='simple-text'>Найдём оптимальное сопротивление R и минимально допустимую мощность резистора PR.</p><p class='simple-text'>Сначала поймём какое напряжение должен взять на себя резистор:</p><img src='img/схема43.png' alt='sheme' class='sheme'><p class='simple-text'>По закону Ома найдём значение сопротивления, которое обеспечит такое падение:</p><img src='img/схема44.png' alt='sheme' class='sheme'><p class='simple-text'>Таким образом:</p><p class='simple-text'>При сопротивлении более 135 Ом яркость будет ниже заявленной.</p><p class='simple-text'>При сопротивлении менее 135 Ом срок жизни светодиода будет меньше.</p><p class='simple-text'>Теперь найдём мощность, которую при этом резистору придётся рассеивать:</p><img src='img/схема45.png' alt='sheme' class='sheme'><p class='simple-text'>Это означает, что при мощности резистора менее 54 мВт резистор перегорит.</p><h1 class='small-topic-2'>Простое правило</h1><p class='simple-text'>Чтобы не заниматься расчётами резистора каждый раз во время проведения экспериментов, можно просто запомнить правило для самого типичного сценария.</p><p class='simple-text pad-bot'>Для питания 1 светодиода на 20 мА от 5 В используйте резистор от 150 до 360 Ом.</p></aside>"
    },
    {
        "title": "Кнопка",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Кнопка</h1><p class='simple-text'><b>Тактовая кнопка</b> — простой, всем известный механизм, замыкающий цепь пока есть давление на толкатель.</p><p class='simple-text'>При нажатии кнопки происходит замыкание электрической сети и соединение контактов. Выводы соединяются методом пайки с контактами на материнской плате. Этот простой механизм позволяет управлять любыми электронными устройствами на включение/выключение и переключение.</p><img src='img/схема46.png' alt='sheme' class='sheme'><p class='simple-text'>Кнопки с 4 контактами стоит рассматривать, как 2 пары рельс, которые соединяются при нажатии.</p><h1 class='small-topic-2'>Эффект дребезга</h1><img src='img/схема47.png' alt='sheme' class='sheme'><p class='simple-text'>При замыкании и размыкании между пластинами кнопки возникают микроискры, провоцирующие до десятка переключений за несколько миллисекунд. Явление называется дребезгом (англ. bounce). Это нужно учитывать, если необходимо фиксировать «клики».</p><h1 class='small-topic-2'>Схема подключения</h1><p class='simple-text'>Напрашивается подключение напрямую. Но это наивный, неверный способ.</p><img src='img/схема48.png' alt='sheme' class='sheme'><p class='simple-text'>Пока кнопка нажата, выходное напряжение Vout = Vcc, но пока она отпущена, Vout ≠ 0. Кнопка и провода в этом случае работают как антенна, и Vout будет «шуметь», принимая случайные значения «из воздуха».</p><p class='simple-text'>Пока соединения нет, необходимо дать резервный, слабый путь, делающий напряжение определённым. Для этого используют один из двух вариантов.</p><h1 class='small-topic-2'>Схема со стягивающим резистором</h1><img src='img/схема49.png' alt='sheme' class='sheme'><p class='simple-text'>Есть нажатие: Vout = Vcc</p><p class='simple-text'>Нет нажатия: Vout = 0</p><h1 class='small-topic-2'>Схема с подтягивающим резистором</h1><img src='img/схема50.png' alt='sheme' class='sheme'><p class='simple-text'>Есть нажатие: Vout = 0</p><p class='simple-text pad-bot'>Нет нажатия: Vout = Vcc</p></aside>"
    },
    {
        "title": "Светодиодные сборки",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Светодиодные сборки</h1><p class='simple-text'>Многие компоненты, используемые для индикации, представляют собой несколько отдельных светодиодов в одном корпусе.</p><h1 class='small-topic-2'>Светодиодная шкала</h1><p class='simple-text'><b>Светодиодная шкала</b> — это отдельные светодиоды, каждый со своим анодом и катодом. Светодиодные шкалы бывают различных цветов: синие, зеленые, желтые, красные, цветные. Цвета светодиодных шкал.</p><img src='img/схема51.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Семисегментный индикатор</h1><p class='simple-text'><b>Семисегментный индикатор</b> — это восемь светодиодов в одном корпусе: 7 сегментов + точка. Анод у каждого светодиода отдельный, а катод у всех общий, на ноге 3 или 8.  Устройство отображения цифровой информации</p><img src='img/схема52.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Установка на макетную плату</h1><p class='simple-text'>Для подключения на breadboard’е используйте канавку в центре, чтобы не замкнуть ноги на противоположных сторонах.</p><img src='img/схема53.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Токоограничивающие резисторы</h1><p class='simple-text'>Самая основная роль <b>токоограничивающих резисторов</b> - это контроль тока, который будет протекать через устройство или проводник.</p><p class='simple-text'>Используйте отдельный резистор для каждого светодиода, иначе при разном количестве включенных сегментов их яркость будет «скакать».</p><p class='simple-text'>Даже в случае, когда все светодиоды включаются и выключаются синхронно, лучше придерживаться этого правила. Светодиоды могут чуть отличаться своей вольт-амперной характеристикой друг от друга. Первый открывшийся пропустит через себя ток, предназначенный для всех. Из-за чего он может выйти из строя и «эстафета» перейдёт к следующему.</p><img src='img/схема54.png' alt='sheme' class='sheme pad-bot'></aside>"
    },
    {
        "title": "Биполярный транзистор",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Биполярный транзистор</h1><p class='simple-text'><b>Транзистор</b> — это электронная кнопка. На кнопку нажимают пальцем, а на биполярный транзистор — током.</p><p class='simple-text'>Красиво, но громоздко и непрактично:</p><img src='img/схема55.png' alt='sheme' class='sheme'><p class='simple-text'>Нога, выполняющая роль «кнопки» называется база (англ. base)</p><p class='simple-text'>Пока через базу течёт небольшой ток, транзистор открыт:</p><p class='simple-text'>Большой ток может втекать в коллектор (англ. collector)</p><p class='simple-text'>и вытекать из эмиттера (англ. emitter)</p><h1 class='small-topic-2'>Основные характеристики</h1><img src='img/схема56.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Типовая схема подключения</h1><img src='img/схема57.png' alt='sheme' class='sheme'><p class='simple-text'>Транзистор усиливает максимально допустимый ток в hfe раз:</p><img src='img/схема58.png' alt='sheme' class='sheme pad-bot'></aside>"
    },
    {
        "title": "Полевой транзистор",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Полевой транзистор</h1><p class='simple-text'>Полевой MOSFET-транзистор — ключ для управления большими токами при помощи небольшого напряжения.</p><img src='img/схема59.png' alt='sheme' class='sheme'><p class='simple-text'>«Кнопка» называется затвором (англ. gate)</p><p class='simple-text'>Пока на затворе есть небольшое напряжение, транзистор открыт:</p><p class='simple-text'>Большой ток может втекать в сток (англ. drain)</p><p class='simple-text'>и вытекать из истока (англ. source)</p><p class='simple-text'>В отличие от биполярного транзистора полевой контролируется именно напряжением, а не током. Т.е. в открытом состоянии ток через затвор не идёт.</p><p class='simple-text'>Используйте MOSFET для управления большими токами, от сотен миллиампер, когда дешёвого биполярного транзистора уже не достаточно.</p><h1 class='small-topic-2'>Основные характеристики</h1><img src='img/схема60.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Типовая схема подключения</h1><img src='img/схема61.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рассеивание тепла</h1><p class='simple-text'>Транзистор не идеален и часть пропускаемой мощности превращается в тепло.</p><img src='img/схема62.png' alt='sheme' class='sheme'><p class='simple-text pad-bot'>Если PH превысит PD, без помощи дополнительного охлаждения транзистор сгорит.</p></aside>"
    },
    {
        "title": "Пьезодинамик",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Пьезодинамик</h1><p class='simple-text'>Пьезоизлучатель звука (англ. buzzer) переводит переменное напряжение в колебание мембраны, которая в свою очередь создаёт звуковую волну. Электроакустический компонент, который используется в системах воспроизведения звука и ультразвуковых приборах.</p><img src='img/схема63.png' alt='sheme' class='sheme'><p class='simple-text'>Иначе говоря, пьезодинамик — это конденсатор, который звучит при зарядке и разрядке.</p><h1 class='small-topic-2'>Основные характеристики</h1><img src='img/схема64.png' alt='sheme' class='sheme'><p class='simple-text'><b>Амплитудно-частотная характеристика (АЧХ)</b> определяет громкость звука в зависимости от частоты управляющего сигнала, который и определяет высоту звучащей ноты.</p><img src='img/схема65.png' alt='sheme' class='sheme'><p class='simple-text'>Идеальная АЧХ — это прямая, т.е. одинаковая громкость вне зависимости от частоты. Но мир не идеален и разные виды излучателей имеют разные отклонения от идеала.</p><h1 class='small-topic-2'>Подключение напрямую</h1><p class='simple-text'>Пьезодинамик потребляет всего пару мА, поэтому можно смело подключать его прямо к микроконтроллеру.</p><img src='img/схема66.png' alt='sheme' class='sheme'><p class='simple-text'>Для звучания нужно подавать на динамик квадратную волну. Какой частоты будет волна, такой частоты будет и звук.</p><img src='img/схема67.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Подключение с регулировкой громкости</h1><img src='img/схема68.png' alt='sheme' class='sheme pad-bot'></aside>"
    },
    {
        "title": "Мотор",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Мотор</h1><p class='simple-text'>Мотор переводит электрическую энергию в механическую энергию вращения.</p><img src='img/схема76.png' alt='sheme' class='sheme'><p class='simple-text'>Самый простой вид мотора — коллекторный. При подаче напряжения в одном направлении вал крутится по часовой стрелке, в обратном направлении — против часовой.</p><h1 class='small-topic-2'>Основные характеристики</h1><img src='img/схема77.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Крутящий момент</h1><img src='img/схема78.png' alt='sheme' class='sheme'><p class='simple-text'>Крутящий момент определяет какая сила воздействует на точку рычага на заданном расстоянии от оси вращения.</p><img src='img/схема79.png' alt='sheme' class='sheme'><p class='simple-text'>Силу иногда упрощённо измеряют в килограммах против гравитации Земли. А крутящий момент — в кг×см. Американцы любят измерять крутящий момент в унциях на дюйм (англ. oz×in).</p><h1 class='small-topic-2'>Схема подключения без возможности 	реверса</h1><p class='simple-text'><b>Моторы</b> — мощные потребители с рядом побочных эффектов. Для управления ими необходимы дополнительные компоненты.</p><img src='img/схема80.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Предельные характеристики</h1><p class='simple-text pad-bot'>IS всегда много больше IF и для хобби-моторов составляет до 2 А. Выбирайте транзистор и диод, способные выдержать этот ток или не допускайте блокировки мотора.</p></aside>"
    },
    {
        "title": "Широтно-импульсная модуляция (ШИМ, PWM)",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Широтно-импульсная модуляция (ШИМ, PWM)</h1><p class='simple-text'>Что такое широтно-импульсная модуляция (ШИМ)? Широтно-импульсная модуляция, или PWM (pulse-width modulation) — это тип цифрового сигнала, который модулируется для управления мощностью, скоростью и/или положением устройств в автоматизированной системе.</p><p class='simple-text'>Микроконтроллеры обычно не могут выдавать произвольное напряжение. Они могут выдать либо напряжение питания (например, 5 В), либо землю (т.е. 0 В)</p><p class='simple-text'>Но уровнем напряжения управляется многое: например, яркость светодиода или скорость вращения мотора. Для симуляции неполного напряжения используется ШИМ.</p><img src='img/схема69.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Применение</h1><p class='simple-text'>Выход микроконтроллера переключается между землёй и Vcc тысячи раз в секунду. Или, как ещё говорят, имеет частоту в тысячи герц. Глаз не замечает мерцания более 50 Гц, поэтому нам кажется, что светодиод не мерцает, а горит в полсилы.</p><p class='simple-text'>Аналогично, разогнанный мотор не может остановить вал за миллисекунды, поэтому ШИМ-сигнал заставит вращаться его в неполную силу.</p><p class='simple-text'>Некоторые возможности применения ШИМ-сигнала: управление скоростью и положением двигателя, регулирование яркости света, регулирование напряжения переменного и постоянного тока, обеспечение регулируемых профилей ускорения и замедления для двигателей, снижение электромагнитных помех, обеспечение точной передачи сигналов и т.д.</p><h1 class='small-topic-2'>Скважность</h1><p class='simple-text'>Отношение полного периода к времени включения называют скважностью (англ. duty cycle). Рассмотрим несколько сценариев при напряжении питания Vcc равным 5 вольтам.</p><h1 class='small-topic-2'>50% — эквивалент 2,5 В</h1><img src='img/схема70.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>10% — эквивалент 0,5 В</h1><img src='img/схема71.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>90% — эквивалент 4,5 В</h1><img src='img/схема72.png' alt='sheme' class='sheme pad-bot'></aside>"
    },
]