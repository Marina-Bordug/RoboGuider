let list = [
    {
        "title": "Маячок",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Маячок</h1><a href='https://youtu.be/vFpTqXtd43k?si=rr1vuxSHutO7Bi60' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/FM4TPt93Vp0?si=g02YlKYWQUB35db6' class='linkk'>Видео для помощи 2</a><a href='https://youtu.be/C4OJ6jFaTKE?si=AAex7NnNzB2ASIKl' class='linkk'>Видео для помощи 3</a><p class='simple-text'>Мигание светодиодом на Arduino – первое, что делают на этой платформе начинающие ардуинщики. Проекты, связанные со светодиодами – самые популярные уроки, с которых начинается большинство учебников. </p><h1 class='small-topic-2'>Что мы узнаем:</h1><p class='simple-text'>Как подключить светодиод к ардуино.</p><p class='simple-text'>Повторим процедуру загрузки скетча в микроконтроллер</p><h1 class='small-topic-2'>Алгоритм программы очень прост.</h1><p class='simple-text'>1. Мы должны подать напряжение на светодиод (на тот пин, к которому подсоединен светодиод, в нашем случае, 13).</p><p class='simple-text'>2. Затем ждем некоторое время. Например, секунду.</p><p class='simple-text'>3. После чего убираем напряжение.</p><p class='simple-text'>4. И опять немного ждем, чтобы глаз мог заметить, что света нет.</p><p class='simple-text'>5. Начинаем все с первого пункта</p><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>2 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k1.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k2.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><p class='simple-text'>Не забудьте, как соединены рельсы в беспаечной макетной плате. Если на вашей макетке красная и синяя линии вдоль длинных рельс прерываются в середине, значит проводник внутри макетки тоже прерывается!</p><p class='simple-text'>Катод («минус») светодиода — короткая ножка, именно её нужно соединять с землёй (GND)</p><p class='simple-text'>Не пренебрегайте резистором, иначе светодиод выйдет из строя</p><p class='simple-text'>Выбрать резистор нужного номинала можно с помощью таблицы маркировки или с помощью мультиметра в режиме измерения сопротивления</p><p class='simple-text'>Плата Arduino имеет три пина GND, используйте любой из них</p><h1 class='small-topic-2'>Выполняем действия по шагам – в результате обязательно получим результат.</h1><p class='simple-text'>1. Берем плату Arduino UNO. Убеждаемся, что на ней есть встроенный светодиод.</p><p class='simple-text'>2. Подключаем плату Arduino к компьютеру через USB-кабель. В результате должны загореться лампочки.</p><p class='simple-text'>3. Открываем на компьютере программу Arduino IDE (вы уже должны знать, как это делается или прочитайте статьи на нашем сайте по ссылкам выше).</p><p class='simple-text'>4. Проверяем, что ардуино подключился: найдите в меню «Инструменты», подменю «Порт». Оно должно быть активным. Нажмите на этот пункт и посмотрите список портов. Один из них должен быть отмечен галочкой. Если этого не произошло, выберите порт с самым большим номером и отметьте его. Если это не помогло – смотрите раздел с описанием типичных проблем чуть ниже.</p><img src='img/k3.png' alt='sheme' class='sheme'><p class='simple-text'>1. Проверка порта Ардуино</p><p class='simple-text'>2. Открываем меню Файл. В нем находим подменю «Примеры», и в нем подменю Basics. Находим в открывшемся списке меню строчку Blink и нажимаем на нее. Должно открыться отдельное окно Arduino с текстом программы (в самом верху будет серый текст).</p><img src='img/k4.png' alt='sheme' class='sheme'><p class='simple-text'>1. Найдите в меню кнопку “загрузить скетч” (со стрелочкой) и нажмите ее. Начнется процесс проверки (компиляции) скетча и загрузки в плату.</p><p class='simple-text'>2. После того, как скетч загружен и в статусном окне внизу появится надпись «Загрузка завершена», можно проверять результат. Посмотрите на плату – вы должны увидеть мигающий огонек. Значит, мы сделали это!</p><p class='simple-text'>3. Проверьте, что программа работает как надо – замерьте паузы между включением и выключением.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k5.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Процедура setup выполняется один раз при запуске микроконтроллера. Обычно она используется для конфигурации портов микроконтроллера и других настроек</p><p class='simple-text'>После выполнения setup запускается процедура loop, которая выполняется в бесконечном цикле. Именно этим мы пользуемся в данном примере, чтобы маячок мигал постоянно</p><p class='simple-text'>Процедуры setup и loop должны присутствовать в любой программе (скетче), даже если вам не нужно ничего выполнять в них — пусть они будут пустые, просто не пишите ничего между фигурными скобками. Например:</p><img src='img/k6.png' alt='sheme' class='sheme'><p class='simple-text pad-bot'>Запомните, что каждой открывающей фигурной скобке { всегда соответствует закрывающая }. Они обозначают границы некого логически завершенного фрагмента кода. Следите за вложенностью фигурных скобок. Для этого удобно после каждой открывающей скобки увеличивать отступ на каждой новой строке на один символ табуляции (клавиша Tab)</p><p class='simple-text'>Обращайте внимание на ; в концах строк. Не стирайте их там, где они есть, и не добавляйте лишних. Вскоре вы будете понимать, где они нужны, а где нет.</p><p class='simple-text'>Функция digitalWrite(pin, value) не возвращает никакого значения и принимает два параметра:</p><p class='simple-text'>	 pin — номер цифрового порта, на который мы отправляем сигнал</p><p class='simple-text'>	 value — значение, которое мы отправляем на порт. Для цифровых портов значением может быть HIGH (высокое, единица) или LOW (низкое, ноль)</p><p class='simple-text'>Если в качестве второго параметра вы передадите функции digitalWrite значение, отличное от HIGH, LOW, 1 или 0, компилятор может не выдать ошибку, но считать, что передано HIGH. Будьте внимательны</p><p class='simple-text pad-bot'>Обратите внимание, что использованные нами константы: INPUT, OUTPUT, LOW, HIGH, пишутся заглавными буквами, иначе компилятор их не распознает и выдаст ошибку. Когда ключевое слово распознано, оно подсвечивается синим цветом в Arduino IDE</p></aside>"
    },
    {
        "title": "Эксперимент 2. Маячок с нарастающей яркостью",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 2. Маячок с нарастающей яркостью   </h1><a href='https://youtu.be/ZikhME7ZL0o?si=407-n74Zgk08vmGM' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/ZikhME7ZL0o?si=407-n74Zgk08vmGM' class='linkk'>Видео для помощи 2</a><a href='https://youtu.be/ZikhME7ZL0o?si=407-n74Zgk08vmGM' class='linkk'>Видео для помощи 3</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>2 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k7.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k8.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Скетч</h1><img src='img/k9.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Идентификаторы переменных, констант, функций (в этом примере идентификатор LED_PIN) являются одним словом (т.е. нельзя создать идентификатор LED PIN).</p><p class='simple-text'>Идентификаторы могут состоять из латинских букв, цифр и символов подчеркивания _. При этом идентификатор не может начинаться с цифры.</p><img src='img/k10.png' alt='sheme' class='sheme'><p class='simple-text'>Регистр букв в идентификаторе имеет значение. Т.е. LED_PIN, LED_pin и led_pin с точки зрения компилятора — различные идентификаторы</p><p class='simple-text'>Идентификаторы, создаваемые пользователем, не должны совпадать с предопределенными идентификаторами и стандартными конструкциями языка; если среда разработки подсветила введенный идентификтор каким-либо цветом, замените его на другой</p><p class='simple-text'>Директива #define просто говорит компилятору заменить все вхождения заданного идентификатора на значение, заданное после пробела (здесь 9), эти директивы помещают в начало кода. В конце данной директивы точка с запятой ; не допустима</p><p class='simple-text'>Названия идентификаторов всегда нужно делать осмысленными, чтобы при возвращении к ранее написанному коду вам было ясно, зачем нужен каждый из них</p><p class='simple-text'>Также полезно снабжать код программы комментариями: в примерах мы видим однострочные комментарии, которые начинаются с двух прямых слэшей // и многострочные, заключённые между /* </p><img src='img/k11.png' alt='sheme' class='sheme'><p class='simple-text'>комментарии игнорируются компилятором, зато полезны людям при чтении давно написанного, а особенно чужого, кода</p><p class='simple-text'>Функция analogWrite(pin, value) не возвращает никакого значения и принимает два параметра:</p><p class='simple-text'>  pin — номер порта, на который мы отправляем сигнал</p><p class='simple-text pad-bot'>  value — значение скважности ШИМ, которое мы отправляем на порт. Он может принимать целочисленное значение от 0 до 255, где 0 — это 0%, а 255 — это 100%</p></aside>"
    },
    {
        "title": "Эксперимент 3. Светильник с управляемой яркостью",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 3. Светильник с управляемой яркостью</h1><a href='https://youtu.be/dUJgVg-u3Ds?si=864PfVmUEApMRRWq' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>6 проводов «папа-папа»</p><p class='simple-text'>1 потенциометр</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k12.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k13.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Мы подключили «землю» светодиода и переменного резистора (потенциометра) к длинной рельсе «-» макетной платы, и уже ее соединили с входом GND микроконтроллера. Таким образом мы использовали меньше входов и от макетки к контроллеру тянется меньше проводов.</p><p class='simple-text'>Подписи «+» и «-» на макетке не обязывают вас использовать их строго для питания, просто чаще всего они используются именно так и маркировка нам помогает</p><p class='simple-text'>Не важно, какая из крайних ножек потенциометра будет подключена к 5 В, а какая к GND, поменяется только направление, в котором нужно крутить ручку для увеличения напряжения. Запомните, что сигнал мы считываем со средней ножки</p><p class='simple-text'>Для считывания аналогового сигнала, принимающего широкий спектр значений, а не просто 0 или 1, как цифровой, подходят только порты, помеченные на плате как «ANALOG IN» и пронумерованные с префиксом A. Для Arduino Uno — это A0-A5.</p><img src='img/k14.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>С помощью директивы #define мы сказали компилятору заменять идентификатор POT_PIN на A0 — номер аналогового входа. Вы можете встретить код, где обращение к аналоговому порту будет по номеру без индекса A. Такой код будет работать, но во избежание путаницы с цифровыми портами используйте индекс.</p><p class='simple-text'>Переменным принято давать названия, начинающиеся со строчной буквы.</p><p class='simple-text'>Чтобы использовать переменную, необходимо ее объявить, что мы и делаем инструкцией:</p><img src='img/k15.png' alt='sheme' class='sheme'><p class='simple-text'>Для объявления переменной необходимо указать ее тип, здесь — int (от англ. integer) — целочисленное значение в диапазоне от -32 768 до 32 767, с другими типами мы познакомимся позднее</p><p class='simple-text'>Переменные одного типа можно объявить в одной инструкции, перечислив их через запятую, что мы и сделали</p><p class='simple-text'>Функция analogRead(pinA) возвращает целочисленное значение в диапазоне от 0 до 1023, пропорциональное напряжению, поданному на аналоговый вход, номер которого мы передаем функции в качестве параметра pinA</p><p class='simple-text pad-bot'>Обратите внимание, как мы получили значение, возвращенное функцией analogRead(): мы просто поместили его в переменную rotation с помощью оператора присваивания =, который записывает то, что находится справа от него в ту переменную, которая стоит слева</p></aside>"
    },
    {
        "title": "Эксперимент 4. Терменвокс",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 4. Терменвокс</h1><a href='https://youtu.be/bTGZmzx3RNI?si=NrZpvgOUMyrdRwOu' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/iN_RuAC9k2o?si=oeSUe3X3b3_kty8H' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 пьезопищалка</p><p class='simple-text'>6 проводов «папа-папа»</p><p class='simple-text'>1 резистор номиналом 10 кОм</p><p class='simple-text'>1 фоторезистор</p><h1 class='small-topic-2'>Рисованная схема</h1><img src='img/k16.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><img src='img/k17.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><p class='simple-text'>В данной схеме мы используем резистор нового номинала, посмотрите таблицу маркировки, чтобы найти резистор на 10 кОм или воспользуйтесь мультиметром</p><p class='simple-text'>Полярность фоторезистора, как и обычного резистора, не играет роли. Его можно устанавливать любой стороной</p><p class='simple-text'>В данном упражнении мы собираем простой вариант схемы включения пьезодинамика</p><p class='simple-text'>Полярность пьезопищалки роли не играет: вы можете подключать любую из ее ножек к земле, любую к порту микроконтроллера</p><p class='simple-text'>На Arduino Uno использование функции tone мешает использованию ШИМ на 3-м и 11-м портах. Зато можно подключить ее к одному из них</p><p class='simple-text'>Вспомните как устроен делитель напряжения: фоторезистор помещается в позицию R2 — между аналоговым входом и землей. Так мы получаем резистивный фотосенсор.</p><img src='img/k18.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Рисованная схема</h1><p class='simple-text'>Функция map(value, fromLow, fromHigh, toLow, toHigh) возвращает целочисленное значение из интервала [toLow, toHigh], которое является пропорциональным отображением содержимого value из интервала [fromLow, fromHigh]</p><p class='simple-text'>Верхние границы map не обязательно должны быть больше нижних и могут быть отрицательными. К примеру, значение из интервала [1, 10] можно отобразить в интервал [10,-5]</p><p class='simple-text'>Если при вычислении значения map образуется дробное значение, оно будет отброшено, а не округлено</p><p class='simple-text'>Функция mapне будет отбрасывать значения за пределами указанных диапазонов, а также масштабирует их по заданному правилу.</p><p class='simple-text'>Если вам нужно ограничить множество допустимых значений, используйте функцию constrain(value, from, to), которая вернет:</p><p class='simple-text'>  value, если это значение попадает в диапазон [from, to]</p><p class='simple-text'>  from, если value меньше него</p><p class='simple-text'>  to, если value больше него</p><p class='simple-text'>Функция tone(pin, frequency, duration) заставляет пьезопищалку, подключенную к порту pin, издавать звук высотой frequency герц на протяжении duration миллисекунд</p><p class='simple-text'>Параметр duration не является обязательным. Если его не передать, звук включится навсегда. Чтобы его выключить, вам понадобится функция noTone(pin). Ей нужно передать номер порта с пищалкой, которую нужно выключить</p><p class='simple-text'>Одновременно можно управлять только одной пищалкой. Если во время звучания вызвать tone для другого порта, ничего не произойдет.</p><p class='simple-text pad-bot'>Вызов tone для уже звучащего порта обновит частоту и длительность звучан</p></aside>"
    },
    {
        "title": "Эксперимент 5. Ночной светильник",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 5. Ночной светильник</h1><a href='https://youtu.be/iN_RuAC9k2o?si=e7I4suAV_gq6yiaG' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/bTGZmzx3RNI?si=tmZL-4_qwQy9JmDT' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 фоторезистор</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>1 резистор номиналом 10 кОм</p><p class='simple-text'>1 переменный резистор (потенциометр)</p><p class='simple-text'>10 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k19.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k20.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>В этом эксперименте мы устанавливаем фоторезистор между питанием и аналоговым входом, т.е. в позицию R1 в схеме делителя напряжения. Это нам нужно для того, чтобы при уменьшении освещенности мы получали меньшее напряжение на аналоговом входе.</p><p class='simple-text'>Постарайтесь разместить компоненты так, чтобы светодиод не засвечивал фоторезистор.</p><img src='img/k21.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Мы используем новый тип переменных — boolean, которые хранят только значения true (истина, 1) или false (ложь, 0). Эти значения являются результатом вычисления логических выражений. В данном примере логическое выражение — это lightness < threshold. На человеческом языке это звучит как: «освещенность ниже порогового уровня». Такое высказывание будет истинным, когда освещенность ниже порогового уровня. Микроконтроллер может сравнить значения переменных lightness и threshold, которые, в свою очередь, являются результатами измерений, и вычислить истинность логического выражения.</p><p class='simple-text'>Мы взяли это логическое выражение в скобки только для наглядности. Всегда лучше писать читабельный код. В других случаях скобки могут влиять на порядок действий, как в обычной арифметике.</p><p class='simple-text'>В нашем эксперименте логическое выражение будет истинным, когда значение lightness меньше значения threshold, потому что мы использовали оператор <. Мы можем использовать операторы >, <=, >=, ==, !=, которые значат «больше», «меньше или равно», «больше или равно», «равно», «не равно» соответственно.</p><p class='simple-text'>Будьте особенно внимательны с логическим оператором == и не путайте его с оператором присваивания =. В первом случае мы сравниваем значения выражений и получаем логическое значение (истина или ложь), а во втором случае присваиваем левому операнду значение правого. Компилятор не знает наших намерений и ошибку не выдаст, а мы можем нечаянно изменить значение какой-нибудь переменной и затем долго разыскивать ошибку.</p><p class='simple-text'>Условный оператор if («если») — один из ключевых в большинстве языков программирования. С его помощью мы можем выполнять не только жестко заданную последовательность действий, но принимать решения, по какой ветви алгоритма идти, в зависимости от неких условий.</p><p class='simple-text'>У логического выражения lightness < threshold есть значение: true или false. Мы вычислили его и поместили в булеву переменную tooDark («слишком темно»). Таким образом мы как бы говорим «если слишком темно, то включить светодиод»</p><p class='simple-text'>С таким же успехом мы могли бы сказать «если освещенность меньше порогового уровня, то включить светодиод», т.е. передать в if всё логическое выражени</p><img src='img/k22.png' alt='sheme' class='sheme'><p class='simple-text'>За условным оператором if обязательно следует блок кода, который выполняется в случае истинности логического выражения. Не забывайте про обе фигурные скобки {}!</p><p class='simple-text'>Если в случае истинности выражения нам нужно выполнить только одну инструкцию, ее можно написать сразу после if (…) без фигурных скобок:</p><img src='img/k23.png' alt='sheme' class='sheme'><p class='simple-text pad-bot'>Оператор if может быть расширен конструкцией else («иначе»). Блок кода или единственная инструкция, следующий за ней, будет выполнен только если логическое выражение в if имеет значение false, «ложь». Правила, касающиеся фигурных скобок, такие же. В нашем эксперименте мы написали «если слишком темно, включить светодиод, иначе выключить светодиод».</p></aside>"
    },
    {
        "title": "Эксперимент 6. Пульсар",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 6. Пульсар</h1><a href='https://youtu.be/qS7V8hog2EA?si=NUtla7lUBBUG8D7n' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/JI-6VMlEVAk?si=aQJwrwN2xRLvNLa8' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 биполярный транзистор</p><p class='simple-text'>1 светодиодная шкала</p><p class='simple-text'>1 резистор номиналом 1 кОм</p><p class='simple-text'>10 резисторов номиналом 220 Ом</p><p class='simple-text'>13 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k24.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k25.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Светодиодная шкала — это несколько светодиодов в одном корпусе. Нам нужно чтобы питание шло к их анодам, а катоды направлялись к земле. Скорее всего на вашей шкале аноды находятся со стороны маркировки. Если шкала не светится, когда должна, попробуйте перевернуть ее.</p><p class='simple-text'>База биполярного транзистора — это его средняя ножка. Если повернуть транзистор плоской стороной к себе, ножками вниз, то левая ножка это коллектор, а правая — эмиттер.</p><p class='simple-text'>Если эту схему собрать без резистора между базой транзистора и портом Arduino, мы практически устроим короткое замыкание порта на землю. Рано или поздно это выведет из строя транзистор или ножку микроконтроллера.</p><p class='simple-text'>Зачем здесь вообще транзистор? Без него такое количество светодиодов будет потреблять больше тока, чем 40 мА, которые может себе позволить цифровой пин платы. Поэтому мы берем питание из порта 5V, рассчитанного на ток до 500 мА, а на цифровой порт ставим транзистор, чтобы с помощью малого тока управлять большим.</p><p class='simple-text'>В данном случае мы включили 10 светодиодов параллельно, каждый через отдельный резистор. Включать их через один резистор неправильно: даже светодиоды из одной партии имеют минимальный разброс вольт-амперных характеристик, вследствие чего они:</p><p class='simple-text'>  Светились бы с различной яркостью</p><p class='simple-text'>  Из-за минимальной разницы во времени включения, больший ток, прошедший через первый включившийся светодиод, мог бы вывести его из строя. И так по цепочке.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k26.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Как мы уже знаем, analogWrite(pin, value) в качестве value принимает значения от 0 до 255. Если передать значение из-за пределов этого диапазона, функция сработает, но в общем случае вы получите неожиданный результат.</p><p class='simple-text'>Оператор X % Y дает остаток от деления X на Y. Если X меньше Y, т.е. целая часть результата деления равна 0, оператор % будет возвращать X. Таким образом:</p><p class='simple-text'>  Пока brightness + 1 меньше 256, в brightness записывается значение brightness + 1</p><p class='simple-text'>  Как только brightness + 1 принимает значение 256, результатом (brightness + 1) % 256 становится 0 и на следующей итерации loop() всё начинается сначала.</p><p class='simple-text'>Оператор % работает только с целыми операндами.</p><p class='simple-text pad-bot'>В выражении (brightness + 1) % 256 скобки используются для назначения порядка действий. Операция % имеет больший приоритет, чем +, а сложение нам нужно выполнять раньше. С операциями умножения и деления оператор взятия остатка имеет одинаковый приоритет.</p></aside>"
    },
    {
        "title": "Эксперимент 7. Бегущий огонёк",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 7. Бегущий огонёк</h1><a href='https://youtu.be/YXeoJizFEbE?si=jLXvkRtbOSUiYS63' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиодная шкала</p><p class='simple-text'>10 резисторов номиналом 220 Ом</p><p class='simple-text'>11 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k27.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k28.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Обратите внимание, что в данном эксперименте резисторы установлены между катодами и землей в отличие от эксперимента пульсар.</p><p class='simple-text'>Мы подключаем светодиоды к цифровым портам, начиная с порта 2. Мы можем использовать порты 0 и 1, но они являются каналами передачи данных последовательного порта и для каждой перепрошивки платы придется отключать устройства, подключенные к ним.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k29.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>С помощью выражения for мы организуем цикл со счетчиком. В данном случае для настройки портов на выход. Чтобы сделать такой цикл, нужно:</p><p class='simple-text'>Инициализировать переменную-счетчик, присвоив ей первоначальное значение. В нашем случае: int pin = FIRST_LED_PIN</p><p class='simple-text'>Указать условие, до достижения которого будет повторяться цикл. В нашем случае: pin <= LAST_LED_PIN</p><p class='simple-text'>Определить правило, по которому будет изменяться счетчик. В нашем случае ++pin (см. ниже об операторе ++).</p><p class='simple-text'>Например, можно сделать цикл for (int i = 10; i > 0; i = i - 1). В этом случае:</p><p class='simple-text'>Переменной i присваивается значение 10</p><p class='simple-text'>Это значение удовлетворяет условию i > 0</p><p class='simple-text'>Поэтому блок кода, помещенный в цикл, выполняется первый раз</p><p class='simple-text'>Значение i уменьшается на единицу, согласно заданному правилу, и принимает значение 9</p><p class='simple-text'>Блок кода выполняется второй раз.</p><p class='simple-text'>Всё повторяется снова и снова вплоть до значения i равного 0</p><p class='simple-text'>Когда i станет равна 0, условие i > 0 не выполнится, и выполнение цикла закончится</p><p class='simple-text'>Контроллер перейдет к коду, следующему за циклом for</p><p class='simple-text'>Помещайте код, который нужно зациклить, между парой фигурных скобок {}, если в нем больше одной инструкции.</p><p class='simple-text'>Переменная-счетчик, объявляемая в операторе for, может использоваться внутри цикла. Например, в данном эксперименте pin последовательно принимает значения от 2 до 11 и, будучи переданной в pinMode, позволяет настроить 10 портов одной строкой, помещенной в цикл.</p><p class='simple-text'>Переменные-счетчики видны только внутри цикла. Т.е. если обратиться к pin до или после цикла, компилятор выдаст ошибку о необъявленной переменной.</p><p class='simple-text'>Конструкция i = i - 1 в пояснении выше не является уравнением! Мы используем оператор присваивания = для того, чтобы в переменную i поместить значение, равное текущему значению i, уменьшенному на 1.</p><p class='simple-text'>Выражение ++pin — это т.н. оператор инкремента, примененный к переменной pin. Эта инструкция даст тот же результат, что pin = pin + 1</p><p class='simple-text'>Аналогично инкременту работает оператор декремента --, уменьшающий значение на единицу. Подробнее об этом в статье про арифметические операции.</p><p class='simple-text'>Тип данных unsigned int используют для хранения целых чисел без знака, т.е. только неотрицательных. За счет лишнего бита, который теперь не используется для хранения знака, мы можем хранить в переменной такого типа значения до 65 535.</p><p class='simple-text'>Функция millis возвращает количество миллисекунд, прошедших с момента включения или перезагрузки микроконтроллера. Здесь мы используем ее для отсчета времени между переключениями светодиодов.</p><p class='simple-text'>С помощью выражения (ms / 120) % 10 мы определяем, который из 10 светодиодов должен гореть сейчас. Перефразируя, мы определяем какой отрезок длиной в 120 мс идет сейчас и каков его номер внутри текущего десятка. Мы добавляем порядковый номер отрезка к номеру того порта, который в текущем наборе выступает первым.</p><p class='simple-text pad-bot'>То, что мы гасим светодиод с помощью digitalWrite(pin, LOW) всего через 10 мс после включения не заметно глазу, т.к. очень скоро будет вновь вычислено, какой из светодиодов включать, и он будет включен — только что погашенный или следующий.</p></aside>"
    },
    {
        "title": "Эксперимент 8. Мерзкое пианино",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 8. Мерзкое пианино</h1><a href='https://youtu.be/Y7D1tmlVVvk?si=CjZkxlqoSBMGL4aJ' class='linkk'>Видео для помощи 1</a><a href='https://youtu.be/ZRXytMr5tBs?si=kWRZMMzjM7RH9B7S' class='linkk'>Видео для помощи 2</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 пьезопищалка</p><p class='simple-text'>3 тактовых кнопки</p><p class='simple-text'>3 резистора номиналом 10 кОм</p><p class='simple-text'>10 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k30.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k31.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Ножки тактовой кнопки, расположенные с одной стороны, разомкнуты, когда кнопка не нажата. Ножки, расположенные друг напротив друга на противоположных сторонах макетки находятся на одной «рельсе». Воспользовавшись этим, мы можем расположить резистор с одной стороны макетки, а провод, подключаемый к порту Arduino, с другой стороны.</p><p class='simple-text'>В данном эксперименте мы подключаем кнопки по схеме с подтягивающим резистором.</p><p class='simple-text'>Для того, чтобы данный вариант программы работал, важно, чтобы кнопки были подключены к портам, находящимся рядом друг с другом, т.е. имеющим соседние номера.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k32.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Благодаря тому, что в начале программы мы определили FIRST_KEY_PIN и KEY_COUNT, мы можем подключать произвольное количество кнопок к любым идущим друг за другом цифровым пинам, и для корректировки программы нам не придется менять параметры цикла for. Изменить понадобится лишь эти константы:</p><p class='simple-text'>цикл в любом случае пробегает от 0 до KEY_COUNT;</p><p class='simple-text'>перед считыванием порта мы задаем смещение на номер первого используемого порта — FIRST_KEY_PIN.</p><p class='simple-text'>Функция digitalRead(pin) возвращает состояние порта, номер которого передан ей параметром pin. Это может быть состояние HIGH или LOW. Или, выражаясь иначе: высокое напряжение или низкое, 1 или 0, true или false</p><p class='simple-text'>Поскольку мы получаем с порта одно из двух состояний, мы сохраняем его в переменную уже знакомого нам типа boolean, и можем работать с ней как с логическим значением.</p><p class='simple-text'>Мы используем логический оператор отрицания «не» !. Если keyUp имеет значение 0, выражение !keyUp будет иметь значение 1 и наоборот.</p><p class='simple-text'>Поскольку мы собрали схему с подтягивающим резистором, при нажатии кнопки мы будем получать на соответствующем порте 0.</p><p class='simple-text pad-bot'>Действия, описанные в условном выражении if, выполняются, когда его условие имеет значение «истина» (единица). Поэтому для выполнения действия по нажатию, мы инвертируем сигнал с кнопки.</p></aside>"
    },
    {
        "title": "Эксперимент 9. Миксер",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 9. Миксер</h1><a href='https://youtu.be/2H4m6myIDqw?si=D-OmgB7z9Loct2OV' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>беспаечная макетная плата</p><p class='simple-text'>3 тактовых кнопки</p><p class='simple-text'>1 коллекторный двигатель</p><p class='simple-text'>1 выпрямительный диод</p><p class='simple-text'>1 полевой MOSFET-транзистор</p><p class='simple-text'>15 проводов «папа-папа»</p><p class='simple-text'>1 клеммник, если вы используете мотор с проводами, которые плохо втыкаются в макетку</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k33.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k34.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Защитный диод нам нужен для того, чтобы ток обратного направления, который начнет создавать двигатель, вращаясь по инерции, не вывел из строя транзистор.</p><p class='simple-text'>Не перепутайте полярность диода, иначе, открыв транзистор, вы устроите короткое замыкание!</p><p class='simple-text'>Причину отсутствия подтягивающих/стягивающих резисторов в схеме вы поймете, ознакомившись с программой.</p><p class='simple-text'>Мы подключили питание схемы к выходу Vin платы микроконтроллера, потому что, в отличие выхода 5V, отсюда можно получить напряжение, подключенное к плате, без изменений и без ограничений по величине тока.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k35.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Мы использовали новый режим работы портов: INPUT_PULLUP. На цифровых портах Arduino есть встроенные подтягивающие резисторы, которые можно включить указанным образом одновременно с настройкой порта на вход. Именно поэтому мы не использовали резисторы при сборке схемы.</p><p class='simple-text pad-bot'>На каждой итерации цикла мы задаем мотору скорость вращения, пропорциональную текущему значению счетчика. Но выполнение инструкций не дойдет до назначения новой скорости, если при проверке нажатия кнопки она окажется отпущенной. Инструкция continue, которая выполнится в этом случае, отменит продолжение данной итерации цикла и выполнение программы продолжится со следующей. А мотор будет крутиться со скоростью, заданной при последнем нажатии на какую-то из кнопок.</p></aside>"
    },
    {
        "title": "Эксперимент 10. Кнопочный переключатель",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 10. Кнопочный переключатель</h1><a href='https://youtu.be/-vrTtv2Nf4g?si=65k3ZVsfDFDEslLc' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 тактовая кнопка</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>5 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k36.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k37.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Мы могли бы один из контактов кнопки соединить проводом напрямую с одним из входов GND, но мы сначала «раздали» «землю» на длинную рельсу макетки. Если мы работаем с макетной платой, так поступать удобнее, т.к. в схеме могут появляться новые участки, которые тоже нужно будет соединить с «землей»</p><p class='simple-text'>Также полезно руководствоваться соображениями аккуратности изделия, поэтому катод светодиода мы соединяем с другим входом GND отдельным проводом, который не мешает нам работать в середине макетк</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k38.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Поскольку мы сконфигурировали вход кнопки как INPUT_PULLUP, при нажатии на кнопку на данном входе мы будем получать 0. Поэтому мы получим значение true («истина») в булевой переменной buttonIsUp («кнопка отпущена»), когда кнопка отпущена.</p><p class='simple-text'>Логический оператор && («и») возвращает значение «истина» только в случае истинности обоих его операндов. Взглянем на так называемую таблицу истинности для выражения buttonWasUp && !buttonIsUp («кнопка была отпущена и кнопка не отпущена»):</p><img src='img/k39.png' alt='sheme' class='sheme'><p class='simple-text'>Здесь рассмотрены все возможные сочетания предыдущего и текущего состояний кнопки и мы видим, что наш условный оператор if сработает только в случае, когда кнопка нажата только что: предыдущее состояние 1 («была отпущена»), а текущее 0 («не отпущена»).</p><p class='simple-text'>Через 10 миллисекунд мы проверяем еще раз, нажата ли кнопка: этот интервал больше, чем длительность «дребезга», но меньше, чем время, за которое человек успел бы дважды нажать на кнопку. Если кнопка всё еще нажата, значит, это был не дребезг.</p><p class='simple-text'>Мы передаем в digitalWrite не конкретное значение HIGH или LOW, а просто булеву переменную ledEnabled. В зависимости от того, какое значение было для нее вычислено, светодиод будет зажигаться или гаситься.</p><p class='simple-text pad-bot'>Последняя инструкция в buttonWasUp = buttonIsUp сохраняет текущее состояние кнопки в переменную предыдущего состояния, ведь на следующей итерации loop текущее состояние уже станет историей.</p></aside>"
    },
    {
        "title": "Эксперимент 11. Светильник с кнопочным управлением",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 11. Светильник с кнопочным управлением</h1><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>2 тактовых кнопки</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>7 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k40.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k41.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>	Если вы переделываете схему из схемы предыдущего эксперимента, обратите внимание, что на этот раз нам нужно подключить светодиод к порту, поддерживающему ШИМ.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k42.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Мы можем пользоваться не только встроенными функциями, но и создавать собственные. Это обоснованно, когда нам нужно повторять одни и те же действия в разных местах кода или, например, нужно выполнять одни и те же действия над разными данными, как в данном случае: обработать сигнал с цифровых портов 2 и 3.</p><p class='simple-text'>Определять собственные функции можно в любом месте кода вне кода других функций. В нашем примере, мы определили функцию после loop.</p><p class='simple-text'>Чтобы определить собственную функцию, нам нужно:</p><p class='simple-text'>Объявить, какой тип данных она будет возвращать. В нашем случае это boolean. Если функция только выполняет какие-то действия и не возвращает никакого значения, используйте ключевое слово void</p><p class='simple-text'>Назначить функции имя — идентификатор. Здесь действуют те же правила, что при именовании переменных и констант. Называть функции принято в том же стиле какПеременные.</p><p class='simple-text'>В круглых скобках перечислить передаваемые в функцию параметры, указав тип каждого. Это является объявлением переменных, видимых внутри вновь создаваемой функции, и только внутри нее. Например, если в данном эксперименте мы попробуем обратиться к wasUp или isUp из loop() получим от компилятора сообщение об ошибке. Точно так же, переменные, объявленные в loop, другим функциям не видны, но их значения можно передать в качестве параметров.</p><p class='simple-text'>Между парой фигурных скобой написать код, выполняемый функцией</p><p class='simple-text'>Если функция должна вернуть какое-то значение, с помощью ключевого слова return указать, какое значение возвращать. Это значение должно быть того типа, который мы объявили</p><p class='simple-text'>Так называемые глобальные переменные, т.е. переменные, к которым можно обратиться из любой функции, обычно объявляются в начале программы. В нашем случае — это brightness.</p><p class='simple-text'>Внутри созданной нами функции handleClick происходит всё то же самое, что в эксперименте «Кнопочный переключатель».</p><p class='simple-text'>Поскольку при шаге прироста яркости 35 не более чем через восемь нажатий подряд на одну из кнопок значение выражения brightness + delta выйдет за пределы интервала [0, 255]. С помощью функции constrain мы ограничиваем допустимые значения для переменной brightness указанными границами интервала.</p><p class='simple-text'>В выражении plusUp = handleClick(PLUS_BUTTON_PIN, plusUp, +35) мы обращаемся к переменной plusUp дважды. Поскольку = помещает значение правого операнда в левый, сначала вычисляется, что вернет handleClick. Поэтому когда мы передаем ей plusUp в качестве параметра, она имеет еще старое значение, вычисленное при прошлом вызове handleClick.</p><p class='simple-text pad-bot'>Внутри handleClick мы вычисляем новое значение яркости светодиода и записываем его в глобальную переменную brightness, которая на каждой итерации loop просто передается в analogWrite.</p></aside>"
    },
    {
        "title": "Эксперимент 12. Кнопочные ковбои",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 12. Кнопочные ковбои</h1><a href='https://youtu.be/InesTTgL7JU?si=qgrM_MbrNpP7Cja8' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>2 тактовых кнопки</p><p class='simple-text'>2 резистора номиналом 220 Ом</p><p class='simple-text'>2 светодиода</p><p class='simple-text'>1 пьезопищалка</p><p class='simple-text'>10 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k43.png' alt='sheme' class='sheme'> <h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k44.png' alt='sheme' class='sheme'> <h1 class='small-topic-2'>Скетч</h1><img src='img/k45.png' alt='sheme' class='sheme'> <h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Массив состоит из элементов одного типа, в нашем случае int.</p><p class='simple-text'>Объявить массив можно следующими способами:</p><img src='img/k46.png' alt='sheme' class='sheme'><p class='simple-text'>Когда мы объявляем массив с указанием количества его элементов n, это число всегда на 1 больше, чем номер последнего элемента (n-1), т.к. индекс первого элемента — 0.</p><p class='simple-text'>Считать или записать значение элемента массива можно, обратившись к нему по индексу, например firstArray[2] или buttonState[counter], где counter — переменная, такая как счетчик цикла</p><p class='simple-text'>В переменных типа long можно хранить значения до 2 147 483 647. unsigned int в этом случае нам будет недостаточно, потому что 65 535 миллисекунд пройдут чуть больше чем за минуту!</p><p class='simple-text'>Функция random(min, max) возвращает целое псевдослучайное число в интервале [min, max]. Для драматичности каждая игра начинается с паузы случайной длины.</p><p class='simple-text'>Благодаря массивам в этом эксперименте мы настраиваем порты, считываем кнопки и включаем светодиоды в циклах со счетчиком, который используется как индекс элемента.</p><p class='simple-text'>Мы используем цикл for без условия его завершения, поэтому пока мы явно того не потребуем, цикл будет крутиться до бесконечности.</p><p class='simple-text'>Мы использовали выражение player = (player+1) % PLAYER_COUNT для счётчика цикла, чтобы не только увеличивать его на единицу каждый раз, но и обнулять при достижении последнего игрока.</p><p class='simple-text pad-bot'>Инструкция break прекращает работу цикла и выполнение программы продолжается с инструкции после его конца.</p></aside>"
    },
    {
        "title": "Эксперимент 13. Секундомер",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 13. Секундомер</h1><a href='https://youtu.be/l4lS6iSQH5E?si=4NZs1mZxpP-NGu3K' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 семисегментный индикатор</p><p class='simple-text'>7 резисторов номиналом 220 Ом</p><p class='simple-text'>9 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/K47.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/K48.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Выводы 3 и 8 семисегментного индикатора оба являются катодами, к земле можете подключать любой из них.</p><p class='simple-text'>Внимательно рассмотрите схему, сопоставьте сегменты индикатора с номерами его ножек, а те, в свою очередь, с пинами Arduino, к которым мы их подключаем.</p><p class='simple-text'>Вывод 5 индикатора — это точка. Мы не используем её в этом эксперименте</p><p class='simple-text'>Сегменты индикатора — просто светодиоды, поэтому мы используем резистор с каждым из них.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/K49.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Мы создали массив типа byte: каждый его элемент это 1 байт, 8 бит, может принимать значения от 0 до 255.</p><p class='simple-text'>Символы арабских цифр закодированы состоянием пинов, которые соединены с выводами соответствующих сегментов: 0, если сегмент должен быть выключен, и 1, если включен.</p><p class='simple-text'>В переменную mask мы помещаем тот элемент массива numberSegments, который соответствует текущей секунде, вычисленной в предыдущей инструкции.</p><p class='simple-text'>В цикле for мы пробегаем по всем сегментам, извлекая с помощью встроенной функции bitRead нужное состояние для текущего пина, в которое его и приводим с помощью digitalWrite и переменной enableSegment</p><p class='simple-text pad-bot'>bitRead(x, n) возвращает boolean значение: n-ный бит справа в байте x</p></aside>"
    },
    {
        "title": "Эксперимент 14. Счётчик нажатий",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 14. Счётчик нажатий</h1><a href='https://youtube.com/shorts/MDk5V9papqM?si=RchuFdRw0OtWXfgH' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 тактовая кнопка</p><p class='simple-text'>1 выходной сдвиговый регистр 74HC595</p><p class='simple-text'>1 семисегментный индикатор</p><p class='simple-text'>7 резисторов номиналом 220 Ом</p><p class='simple-text'>24 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/K50.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/K51.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>В этом эксперименте мы впервые используем микросхему, в данном случае — выходной сдвиговый регистр 74HC595. Микросхемы полезны тем, что позволяют решать определенную задачу, не собирая каждый раз стандартную схему.</p><p class='simple-text'>Выходной сдвиговый регистр дает нам возможность «сэкономить» цифровые выходы, использовав всего 3 вместо 8. Каскад регистров позволил бы давать 16 и т.д. сигналов через те же три пина.</p><p class='simple-text'>Перед использованием микросхемы нужно внимательно изучить схему ее подключения в datasheet’е. Для того, чтобы понять, откуда считать ножки микросхемы, на них с одной стороны есть полукруглая выемка. Если мы расположим нашу 74HC595 выемкой влево, то в нижнем ряду будут ножки 1—8, а в верхнем 16—9.</p><p class='simple-text'>На принципиальной схеме нашего эксперимента ножки расположены в другом порядке, чтобы не вышло путаницы в соединениях. Назначения выводов согласно datasheet’у подписаны внутри изображения микросхемы, номера ножек — снаружи.</p><p class='simple-text'>Напомним, что на изображении семисегментного индикатора подписаны номера его ножек и их соответствие сегментам.</p><img src='img/K52.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Обратите внимание, что в этом эксперименте кодировки символов отличаются от кодировок из эксперимента «Секундомер».</p><p class='simple-text'>Для того, чтобы передать порцию данных, которые будут отправлены через сдвиговый регистр далее, нам нужно подать LOW на latch pin (вход STcp микросхемы), затем передать данные, а затем отправить HIGH на latch pin, после чего на соответствующих выходах 74HC595 появится переданная комбинация высоких и низких уровней сигнала.</p><p class='simple-text'>Для передачи данных мы использовали функцию shiftOut(dataPin, clockPin, bitOrder, value). Функция ничего не возвращает, а в качестве параметров ей нужно сообщить</p><p class='simple-text'>пин Arduino, который подключен ко входу DS микросхемы (data pin),</p><p class='simple-text'>пин Arduino, соединенный со входом SHcp (clock pin),</p><p class='simple-text'>порядок записи битов: LSBFIRST (least significant bit first) — начиная с младшего, или MSBFIRST (most significant bit first) — начиная со старшего,</p><p class='simple-text pad-bot'>байт данных, который нужно передать. Функция работает с порциями данных в один байт, так что если вам нужно передать больше, придется вызывать ее несколько раз.</p></aside>"
    },
    {
        "title": "Эксперимент 15. Комнатный термометр",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 15. Комнатный термометр</h1><a href='https://youtu.be/nN05rFdJwjk?si=4gt5kZ1vB3QCKp31' class='linkk'>Видео для помощи</a><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиодная шкала</p><p class='simple-text'>1 резистор номиналом 10 кОм</p><p class='simple-text'>1 термистор</p><p class='simple-text'>10 резисторов номиналом 220 Ом</p><p class='simple-text'>14 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k53.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k54.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Термистор мы включили в известную нам схему делителя напряжения.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k54.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Директивы для подключения библиотек #include включаются в начало программы.</p><p class='simple-text'>В этом эксперименте мы подключаем библиотеку math.h для того, чтобы использовать функцию взятия натурального логарифма x log(x).</p><p class='simple-text'>В переменных типа float можно хранить дробные числа, числа с плавающей точкой.</p><p class='simple-text'>При использовании переменных данного типа имейте в виду:</p><p class='simple-text'>при операциях с их использованием, указывайте нулевую дробную часть у целых констант, как в примере</p><p class='simple-text'>они могут принимать значения от -3.4028235×1038 до 3.4028235×1038,</p><p class='simple-text'>при этом количество значащих цифр может быть 6-7: всех цифр, не только после запятой!</p><p class='simple-text'>точность вычислений с такими данными невелика, у вас могут возникнуть неожиданные ошибки, например, при использовании float в условном операторе. Не полагайтесь на точность!</p><p class='simple-text'>вычисления с float происходят медленнее, чем с целыми числами</p><p class='simple-text pad-bot'>Показания термистора связаны с температурой нелинейно, поэтому нам приходится использовать такую громоздкую формулу.</p></aside>"
    },
    {
        "title": "Эксперимент 16. Метеостанция",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 16. Метеостанция</h1><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 резистор номиналом 10 кОм</p><p class='simple-text'>1 термистор</p><p class='simple-text'>3 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k56.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k57.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Скетч</h1><img src='img/k58.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Очень часто бывает полезно обмениваться данными, например, с компьютером. В частности, для отладки работы устройства: можно, например, смотреть, какие значения принимают переменные.</p><p class='simple-text'>В данном эксперименте мы знакомимся со стандартным объектом Serial, который предназначен для работы с последовательным портом (UART) Arduino, и его методами (функциями, созданными для работы с данным объектом) begin(), print() и println(), которые вызываются после точки, идущей за именем объекта:</p><p class='simple-text'>чтобы обмениваться данными, нужно начать соединение, поэтому Serial.begin(baudrate) вызывается в setup()</p><p class='simple-text'>Serial.print(data) отправляет содержимое data. Если мы хотим отправить текст, можно просто заключить его в пару двойных кавычек: ''. Кириллица, скорее всего, будет отображаться некорректно.</p><p class='simple-text'>Serial.println(data) делает то же самое, только добавляет в конце невидимый символ новой строки.</p><p class='simple-text'>В print() и println() можно использовать второй необязательный параметр: выбор системы счисления, в которой выводить число (это может быть DEC, BIN, HEX, OCT для десятичной, двоичной, шестнадцатеричной и восьмеричной систем счисления соответственно) или количество знаков после запятой для дробных чисел.</p><p class='simple-text'>Например,</p><img src='img/k59.png' alt='sheme' class='sheme'><p class='simple-text'>в мониторе порта даст результат</p><img src='img/k70.png' alt='sheme' class='sheme'><p class='simple-text'>Монитор порта, входящий в Arduino IDE, открывается через меню Сервис или сочетанием клавиш Ctrl+Shift+M. Следите за тем, чтобы в мониторе и в скетче была указана одинаковая скорость обмена данными, baudrate. Скорости 9600 бит в секунду обычно достаточно. Другие стандартные значения можете посмотреть в выпадающем меню справа внизу окна монитора порта.</p><p class='simple-text'>Вам не удастся использовать цифровые порты 0 и 1 одновременно с передачей данных по последовательному порту, потому что по ним также идет передача данных, как и через USB-порт платы.</p><p class='simple-text'>При запуске монитора порта скетч в микроконтроллере перезагружается и начинает работать с начала. Это удобно, если вам нельзя упустить какие-то данные, которые начинаю передаваться сразу же. Но в других ситуациях это может мешать, помните об этом нюансе!</p><p class='simple-text'>Если вы хотите читать какие-то данные в реальном времени, не забывайте делать delay() хотя бы на 100 миллисекунд, иначе бегущие числа в мониторе будет невозможно разобрать. Вы можете отправлять данные и без задержки, а затем, к примеру, скопировать их для обработки в стороннем приложении.</p><p class='simple-text pad-bot'>Последовательность \t выводится как символ табуляции (8 пробелов с выравниванием). Также вы можете использовать, например, последовательность \n для перевода строки. Если вы хотите использовать обратный слеш, его нужно экранировать вторым таким же: \\.</p></aside>"
    },
    {
        "title": "Эксперимент 17. Пантограф",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 17. Пантограф</h1><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 сервопривод</p><p class='simple-text'>1 конденсатор ёмкостью 220 мкФ</p><p class='simple-text'>1 потенциометр</p><p class='simple-text'>11 проводов «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k60.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k61.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Конденсатор в данной схеме нам нужен для того, чтобы при включении сервопривода избежать просадки питания платы.</p><p class='simple-text'>Не забывайте про то, что нужно соблюдать полярность элетролитического конденсатора. Короткая ножка (со стороны белой полосы на корпусе) — «минус».</p><p class='simple-text'>Вы можете соединить провод сервопривода с макетной платой проводами «папа-папа»: коричневый это земля, красный — питание, оранжевый — сигнал.</p><p class='simple-text'>В данном эксперименте мы подключаем питние сервопривода к 5V-выходу Arduino. С одним сервоприводом плата справится, но если в каком-либо проекте вам нужно больше серв, используйте специальные платы-драйвера с отдельным источником питания для серв.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k62.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>В данном эксперименте мы также имеем дело с объектом, на этот раз он нужен для простого управления сервоприводом. Как отмечено в комментариях, в отличие от объекта Serial, объекты типа Servo нам нужно явно создать: Servo myServo, предварительно подключив библиотеку <Servo.h>.</p><p class='simple-text'>Далее мы используем два метода для работы с ним:</p><p class='simple-text'>myServo.attach(pin) — сначала «подключаем» серву к порту, с которым физически соединен его сигнальный провод. pinMode() не нужна, метод attach() займется этим.</p><p class='simple-text'>myServo.write(angle) — задаем угол, т.е. позицию, которую должен принять вал сервопривода. Обычно это 0—180°.</p><p class='simple-text'>myServo здесь это имя объекта, идентификатор, который мы придумываем так же, как названия переменных. Например, если вы хотите управлять двумя захватами, у вас могут быть объекты leftGrip и rightGrip.</p><p class='simple-text pad-bot'>Мы использовали функцию int() для явного преобразования числа с плавающей точкой в целочисленное значение. Она принимает в качестве параметра значение любого типа, а возвращает целое число. Когда в одном выражении мы имеем дело с различными типами данных, нужно позаботиться о том, чтобы не получить непредсказуемый ошибочный результат.</p></aside>"
    },
    {
        "title": "Эксперимент 18. Тестер батареек",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 18. Тестер батареек</h1><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>2 резистора номиналом 10 кОм</p><p class='simple-text'>1 выпрямительный диод</p><p class='simple-text'>1 текстовый экран</p><p class='simple-text'>16 проводов «папа-папа»</p><p class='simple-text'>1 клеммник</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k64.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k65.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Мы подключаем «плюс» батарейки через делитель напряжения с равными плечами (R1 = R2 = 10 кОм), таким образом деля подаваемое напряжение пополам. Поскольку в аналоговый вход Arduino мы можем подавать до 5В, мы можем измерять напряжение до 10В. Не пробуйте измерять большее напряжение, вы можете повредить плату!</p><p class='simple-text'>На принципиальной схеме внутри изображения дисплея подписаны названия его выводов согласно datasheet, а снаружи — номера его ножек.</p><p class='simple-text'>Ножки нашего ЖК-дисплея нумеруются не подряд: 15 и 16 ножки находятся перед 1.</p><p class='simple-text'>Диод пригодится, если пользователь тестера перепутает «+» и «-» батарейки, главное нам самим не забыть про направление, в котором через диод может течь ток, и установить его верно!</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k66.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Если вы используете диод, падение напряжения на котором происходит на другую величину, не забудьте исправить макроопределение DIODE_DROP.</p><p class='simple-text'>В этом эксперименте мы снова пользуемся готовой библиотекой <LiquidCrystal.h> для создания объекта lcd и использования его методов</p><p class='simple-text'>lcd.begin(cols,rows) с помощью которого мы задаем количество колонок и строк нашего дисплея</p><p class='simple-text'>lcd.print(data) для вывода данных. У него есть второй необязательный параметр BASE, передав который, можно выбрать систему счисления, так же, как в примере с Serial.print().</p><p class='simple-text'>lcd.setCursor(col,row) устанавливает курсор в переданную колонку и строку. Последующий вывод будет осуществляться с этого места.</p><p class='simple-text'>При создании lcd мы передали параметрами пины, к которым подключены выводы дисплея, через которые мы будем им управлять и передавать данные.</p><p class='simple-text pad-bot'>О том, как выводить текст кириллицей, и о других подробностях работы с дисплеем в нашей вики есть отдельная статья.</p></aside>"
    },
    {
        "title": "Эксперимент 19. Светильник, управляемый по USB",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 19. Светильник, управляемый по USB</h1><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиод</p><p class='simple-text'>1 резистор номиналом 220 Ом</p><p class='simple-text'>2 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k67.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Схема на макетке</h1><img src='img/k68.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Скетч</h1><img src='img/k69.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>В этой программе мы создаем объект класса String. Это встроенный класс, предназначенный для работы со строками, т.е. с текстом.</p><p class='simple-text'>Не путайте его с типом данных string, который является просто массивом символов. String же позволяет использовать ряд методов для удобной работы со строками.</p><p class='simple-text'>Мы знакомимся с новым видом циклов: цикл с условием while. В отличие от цикла со счетчиком for, цикл while(expression) выполняется до тех пор, пока логическое выражение expression истинно.</p><p class='simple-text'>Метод available() объекта Serial возвращает количество байт, полученных через последовательный порт.</p><p class='simple-text'>В данном эксперименте цикл while работает до тех пор, пока available() возвращает ненулевое значение, любое из которых приводится к true.</p><p class='simple-text'>Переменные типа char могут хранить один символ.</p><p class='simple-text'>В этом примере символ мы получаем методом Serial.read(), который возвращает первый байт, пришедший на последовательный порт, или -1, если ничего не пришло.</p><p class='simple-text'>Обратите внимание, что в if мы сравниваем не пришедший символ с 0 и 9, но их коды. Если пришел какой-то символ, который не является цифрой, мы не будем его добавлять к нашей строке message.</p><p class='simple-text'>Объекты типа String позволяют производить конкатенацию, т.е. объединение строк. Это можно сделать так: message = message + incomingChar, но можно записать в сокращенной форме: message += incomingChar.</p><p class='simple-text'>В этой программе мы дополняем if конструкцией else if. Это еще один условный оператор, который проверяется только в случае ложности выражения, данного первому оператору. Несколько else if могут следовать друг за другом, при этом каждое следующее условие будет проверяться только в случае невыполнения всех предыдущих. Если в конце разместить else, он выполнится только если ни одно из условий не выполнено.</p><p class='simple-text'>Напомним, что последовательностью \n кодируется символ переноса строки. Если он был передан устройству, мы передаем полученные ранее символы как параметр для analogWrite(), которая включает светодиод.</p><p class='simple-text'>Мы используем один из методов String, toInt(), который заставляет считать строку не набором цифр, но числом. Он возвращает значение типа long, при этом, если строка начинается с символа, не являющегося цифрой, будет возвращен 0. Если после цифр, идущих в начале строки, будут символы не-цифры, на них конверсия остновится.</p><p class='simple-text'>Обратите внимание на выпадающее меню внизу монитора порта: чтобы наше устройство получало символ перевода строки, там должно быть выбрано «Новая строка (NL)»</p><p class='simple-text pad-bot'>Пустая строка обозначается так: ''. Опустошив ее, мы готовы собирать новую последовательность символов.</p></aside>"
    },
    {
        "title": "Эксперимент 20. Перетягивание каната",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Эксперимент 20. Перетягивание каната</h1><h1 class='small-topic-2'>Список деталей для эксперимента</h1><p class='simple-text'>1 плата Arduino Uno</p><p class='simple-text'>1 беспаечная макетная плата</p><p class='simple-text'>1 светодиодная шкала</p><p class='simple-text'>10 резисторов номиналом 220 Ом</p><p class='simple-text'>4 резисторов номиналом 10 кОм</p><p class='simple-text'>2 тактовых кнопки</p><p class='simple-text'>2 керамических конденсатора номиналом 100 нФ</p><p class='simple-text'>1 пьезопищалка</p><p class='simple-text'>1 инвертирующий триггер Шмитта</p><p class='simple-text'>24 провода «папа-папа»</p><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k71.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Принципиальная схема</h1><img src='img/k72.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Обратите внимание</h1><p class='simple-text'>Схема подключения кнопок с использованием конденсаторов, резисторов и микросхемы 74HC14, которая называется инвертирующий триггер Шмитта, нужна для аппаратного подавления дребезга. Посмотрите видеоурок на эту тему.</p><p class='simple-text'>В этом эксперименте нам нужно очень много цифровых портов, поэтому нам пришлось использовать порт 0. Пользоваться им неудобно из-за того, что он соединен с одним из каналов последовательного порта, поэтому перед прошивкой микроконтроллера нам придется отключать провод, идущий к пьезопищалке, а после прошивки подключать его обратно.</p><h1 class='small-topic-2'>Скетч</h1><img src='img/k73.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Пояснения к коду</h1><p class='simple-text'>Код нашей обычной программы исполняется инструкция за инструкцией и если мы, например, проверяем состояние датчика, мы к нему обратимся только в те моменты, когда очередь дойдет до соответствующей инструкции. Однако мы можем использовать прерывания:</p><p class='simple-text'>по наступлении определенного события</p><p class='simple-text'>на определенном порту ход программы будет приостанавливаться для выполнения</p><p class='simple-text'>определенной функции, а затем программа продолжит исполняться с того места, где была приостановлена.</p><p class='simple-text'>Arduino Uno позволяет делать прерывания на портах 2 и 3.</p><p class='simple-text'>В setup() прописывается инструкция attachInterrupt(interrupt, action, event), где</p><p class='simple-text'>interrupt может принимать значения INT0 или INT1 для портов 2 и 3 соответственно. Можно задать эти значения и с помощью функции digitalPinToInterrupt(pin), где вместо pin указать номер пина.</p><p class='simple-text'>action — имя функции, которая будет вызываться при наступлении события</p><p class='simple-text'>event — событие, которое мы отслеживаем. Может принимать значение RISING (изменение от низкого уровня сигнала к высокому, от 0 к 1), FALLING (от высокого уровня к низкому, от 1 к 0), CHANGE (от 0 к 1 или от 1 к 0), LOW (при низком уровне сигнала).</p><p class='simple-text'>Глобальные переменные, к которым мы обращаемся из функции, обрабатывающей прерывания, должны объявляться с использованием ключевого слова volatile, как в данном эксперименте volatile int score = 0.</p><p class='simple-text'>Внутри функции, вызываемой по прерыванию, нельзя использовать delay().</p><p class='simple-text'>Функция abs(value) возвращает абсолютное значение value (значение по модулю). Обратите внимание, что функция может сработать некорректно, если передавать ей выражение, которое еще не вычислено, например abs(++a), лучше передавать ей просто переменную.</p><p class='simple-text'>Функция min(val1, val2) вернет меньшее из val1 и val2.</p><p class='simple-text'>Функция max(val1, val2) вернет большее из val1 и val2.</p><p class='simple-text'>В данном эксперименте мы вычисляем значение, которое записывается на светодиоды, прямо в digitalWrite()</p><p class='simple-text'>Мы уже знакомы с логическим «и» (&&). Нередко нужен оператор «логическое «или»: ||. Он возвращает «истину», если хотя бы один из операндов имеет значение «истина». false || false вернет false, а true || true, true || false и false || true вернут true.</p><p class='simple-text pad-bot'>Мы использовали while(true){} для того, чтобы loop() остановился после того, как кто-то выиграл: у while всегда истинное условие и он бесконечно ничего не выполняет!</p></aside>"
    },
]
