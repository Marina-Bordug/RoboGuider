let list = [
    {
        "title": "Аналоговый сигнал",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Аналоговый сигнал</h1><p class='simple-text'>При использовании аналогового сигнала, показания датчика передаются в виде переменного напряжения на сигнальном проводе. Сигнальное напряжение может принимать значение от 0 В до напряжения питания. Хотя обычно «рабочий диапазон» напряжений более узкий.</p><p class='simple-text'>На Arduino Uno имеется 6 аналоговых входов с помощью которых можно считывать переменное напряжение, и исходя из его значения получать значения с датчика. Эти входы объединены на плате в группу «Analog In» и пронумерованы от A0 до A5.</p><h1 class='small-topic-2'>Протокол</h1><p class='simple-text'>Между измеряемой величиной и возвращаемым обратно напряжением установлена определённая зависимость. Например: чем больше величина, тем больше напряжение; или наоборот: чем больше величина, тем напряжение меньше. Иногда зависимость более сложная: напряжение растёт до определённого значения, затем падает пропорционально ему. Всё зависит от сенсора.</p><p class='simple-text'>Так например, инфракрасный дальномер измеряет расстояние до объекта перед ним. Для него чем меньше расстояние, тем больше напряжение. Если объект находится на расстоянии 20 см, сенсор выдаёт ~2,5 В на сигнальном проводе; на расстоянии 60 см ~ 1 В; на расстоянии 150 см ~ 0,4 В. Точная диаграмма зависимости напряжения от расстояния для инфракрасного дальномера от Sharp приведена в его datasheet’е.</p><img src='img/n1.png' alt='sheme' class='sheme'><p class='simple-text'>Для других сенсоров диаграммы можно так же найти в документации или получить экспериментально.</p><h1 class='small-topic-2'>Программирование</h1><p class='simple-text'>Считать данные с аналогового сенсора крайне просто. Для этого в Arduino существует стандартная функция analogRead. Так, например, если вы подключили сенсор к контакту A5, чтобы получить показания сенсора в переменную value достаточно исполнить:</p><img src='img/n2.png' alt='sheme' class='sheme'><p class='simple-text'>Диапазон входного напряжения от 0 до 5 В в программе проецируется на диапазон целочисленных значений от 0 до 1023. Перевести полученное значение в физические единицы, такие как, например, расстояние, поможет функция map. Подробнее об этом рассказывает Джереми Блюм, в своём 4-м видеоуроке по Arduino.</p><p class='simple-text'>Таким образом, программа, которая раз в секунду считывает показания аналогового сенсора, подключенного к контакту А5, и посылает их на компьютер может выглядеть так:</p><img src='img/n3.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Преимущества и недостатки аналогового сигнала</h1><p class='simple-text'>Преимуществом сенсоров с аналоговым сигналом является крайняя простота их использования с Arduino. Кроме того, поскольку показания датчика можно считывать «из коробки» всего одной командой, драгоценные килобайты памяти на микроконтроллере не расходуются на хранение алгоритма расшифровки протокола, присущего цифровым сенсорам.</p><p class='simple-text'>Главным недостатком аналогового сигнала является неустойчивость к внешним шумам. Если провод от сенсора до микроконтроллера будет достаточно длинным, он начнёт работать как антенна и улавливать внешние электромагнитные поля: провод сам будет влиять на выходное напряжение и тем самым искажать показания. Поэтому разумный предел длины провода для аналогового сенсора — не более 50 см.</p><p class='simple-text'>Чтобы уменьшить влияние помех на полезный сигнал можно воспользоваться усреднением. Так как помехи носят случайный характер, они будут влиять на полезный сигнал тем меньше, чем больше выборок используется для усреднения. С усреднением наш пример будет выглядеть так:</p><img src='img/n4.png' alt='sheme' class='sheme'><p class='simple-text'>Аналоговый сигнал при чтении на Arduino может иметь максимум 1024 градации. С учётом того, что рабочий диапазон почти всегда уже допустимого, полезных градаций ещё меньше. Этого может оказаться недостаточно для высокоточных измерений.</p><p class='simple-text'>На ATmega328p, установленном на Arduino, как и на большинстве других микроконтроллеров аналоговых входов немного. Поэтому количество одновременно контролируемых аналоговых сенсоров ограничено. У Arduino Uno их 6, у Mega 2560 — 16.</p><p class='simple-text pad-bot'>Если какой-либо из недостатков существенен для вашего проекта, обратите внимание на цифровые сенсоры.</p></aside>"
    },
    {
        "title": "Цифровой сигнал",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Цифровой сигнал</h1><p class='simple-text'>При использовании цифрового сигнала сенсор в любой момент времени выдаёт на сигнальный провод либо 0 В, либо напряжение своего питания — 5 В. Промежуточных значений нет. Для того, чтобы абстрагироваться от конкретных значений напряжения, которые не важны при обработке цифровых сигналов, существуют понятия логического нуля (LOW) и логической единицы (HIGH). 0 В — это логический ноль, напряжение питания — это логическая единица.</p><p class='simple-text'>На Arduino Uno имеется 14 цифровых входов, любой из которых может быть использован для подключения такого датчика.</p><h1 class='small-topic-2'>Протокол</h1><p class='simple-text'>Есть простые сенсоры у которых есть всего два состояния: чёрный/не-чёрный, лево/право и т.д. Их очень легко подключить и считать показания: сенсоры передают свой сигнал непрерывно, а значение на сигнальном проводе напрямую соответствует их показаниям. Такой простой протокол называется бинарным.</p><p class='simple-text'>Существуют также сенсоры с цифровым сигналом, которые измеряют множество градаций определённой физической величины вроде расстояния или температуры. Но для передачи своих данных с использованием лишь двух значений, каждый такой сенсор определяет собстенный протокол. В нём описывается какие последовательности нулей и единиц, с какими задержками, как несут в себе передаваемые данные. Принимающая сторона, такая как Arduino, должна реализовать алгоритм, который будет считывать показания в соответствии с протоколом. Протокол у каждого сенсора свой, он описывается в его документации. Arduino — очень популярная платформа, поэтому чаще всего реализацию алгоритма расшифровки можно найти в виде готовой библиотеки, написанной энтузиастами или самим производителем сенсора.</p><h1 class='small-topic-2'>Программирование</h1><p class='simple-text'>Если говорить о цифровых сенсорах с бинарным протоколом, считать данные с него — крайне просто.</p><p class='simple-text'>Поскольку цифровые контакты могут являться как входами, так и выходами, для начала нужно сконфигурировать контакт, к которому подключен сенсор в режим ввода. Это нужно сделать единожды, поэтому функция setup — подходящее для этого место. Для конфигурирования режима используется стандартная функция pinMode. Так, например, если вы подключили сенсор к контакту 9, код конфигурации будет выглядеть так:</p><img src='img/n5.png' alt='sheme' class='sheme'><p class='simple-text'>Затем, чтобы считать состояние в любой момент времени, существует стандартная функция digitalRead. Продолжая пример, чтобы получить состояние сенсора в переменную value достаточно исполнить:</p><img src='img/n6.png' alt='sheme' class='sheme'><p class='simple-text'>Входное напряжение до 2 В проецируется на целочисленное значение 0, что соответствует значению константы LOW; напряжение более 3 В проецируется на целочисленное значение 1, что соответствует значению константы HIGH. Напряжение от 2 до 3 В спроецируется на 0 или 1 случайным образом, но это не является проблемой, так как цифровые сенсоры не должны выдавать такой сигнал.</p><p class='simple-text'>Таким образом, программа, которая раз в секунду считывает показания цифрового сенсора с двумя состояниями, подключенного к контакту 9, и посылает их на компьютер может выглядеть так:</p><img src='img/n7.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Преимущества и недостатки цифрового сигнала</h1><p class='simple-text'>Преимуществом сенсоров с цифровым сигналом и всего двумя состояниями является крайняя простота их использования с Arduino.</p><p class='simple-text'>Однако, если речь идёт о цифровом сенсоре с множеством градаций измеряемой величины, их использование с Arduino не так тривиально, как бинарных или аналоговых: необходимо реализовать расшифровку данных, что требует определённых усилий, а также занимает память микроконтроллера.</p><p class='simple-text pad-bot'>Поскольку возможных значений в цифровом сигнале всего 2, а возможные отклонения в напряжении «округляются» микроконтроллером в ближайшую сторону, такие сенсоры можно подключать с помощью достаточно длинных (много метров) проводов, не опасаясь искажения сигнала из-за влияния на провод внешних электромагнитных полей.</p></aside>"
    },
    {
        "title": "Датчики и сенсоры: теория",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Датчики и сенсоры: теория</h1><p class='simple-text'>К Arduino можно подключить всевозможные сенсоры. В русском языке существуют слова «датчик» и «сенсор», это синонимы и означают по сути одно и то же. Это отдельное устройство, которое способно измерять определённую физическую величину или реагировать на физическое явление и выдавать информацию об этом в виде электрического сигнала.</p><h1 class='small-topic-2'>Классификация</h1><p class='simple-text'>Сенсоры различаются по тому, что они фиксируют. Существуют сенсоры для измерения температуры, расстояния, вибрации, звука, влажности, движения, магнитного поля и многие другие.</p><p class='simple-text'>Также они различаются по типу сигнала. Некоторые передают сигнал в виде переменного напряжения (аналоговые), некоторые в виде последовательности низкого и высокого напряжения (цифровые), другие меняют собственное сопротивление. Тип сигнала определяет, как физические показания проецируются на электрические величины, пригодные для считывания.</p><p class='simple-text'>Далее сенсоры различаются по протоколу. Он определяет, как принимающая сторона (например, Arduino) должна интерпретировать передаваемый сенсором сигнал, чтобы получить значение измеряемой величины. Для одних сенсоров измеряемая величина прямо пропорциональна передаваемому напряжению, другие передают только «да / нет» с помощью двух величин напряжения, третьи передают свои показания в виде последовательности бит, где отсутствию напряжения соответствует 0, а высокому напряжению — 1. Протокол у каждого сенсора свой и определяется производителем датчика.</p><p class='simple-text'>Кроме того, сенсоры различаются по способу физического подключения. Большое количество Arduino-совместимых сенсоров легко подключаются по трём проводам. Другие сенсоры имеют контакты, подходящие для подключения через breadboard.</p><h1 class='small-topic-2'>Подключение и использование</h1><p class='simple-text'>Чтобы соединить любой сенсор с Arduino и начать считывать его показания, нужно:</p><p class='simple-text'>1. Определить, какому типу сигнала соответствует сенсор: аналоговый, цифровой, сопротивление.</p><p class='simple-text'>2. Физически подключить сенсор к Arduino: по трём проводам или через breadboard, в зависимости от сенсора.</p><p class='simple-text'>3. Определить, по какому протоколу передаются данные: зависимость от напряжения, бинарный или свой собственный, и написать программу для их получения.</p><p class='simple-text pad-bot'>Отдельных статьей заслуживают сенсор температуры и влажности, герметичный датчик температуры DS18B20 и аналоговый термометр на базе TMP36.</p></aside>"
    },
    {
        "title": "Языки программирования",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Языки программирования</h1><p class='simple-text'>Итак, у вас есть процессор. Вы наверняка понимаете, что процессор можно как-то запрограммировать, чтобы он делал то, что вы хотите. Но чтобы сделать какую-то полезную работу, необходимо сперва написать полезную программу и отдать её процессору для исполнения.</p><p class='simple-text'>В целом, неважно, с каким именно процессором вы имеете дело: это может быть последний Intel Pentium в вашем ноутбуке или микроконтроллер на плате Arduino. Общие принципы написания программы, т. е. программирования, в обоих случаях одни и те же. Различается лишь быстродействие и объём возможностей по работе с другими устройствами.</p><h1 class='small-topic-2'>Что такое программа и куда её писать</h1><p class='simple-text'>Процессор, несмотря на всю сложность разработки и производства, по сути своей, довольно простая и прямолинейная вещь. Думать он не умеет: то есть, ставить новые задачи, искать и находить решения нетиповых уникальных задач процессор не может (и не сможет). Он умеет лишь тупо, байт за байтом, команда за командой, исполнять инструкции, которые ему подсунули. Этакий тупой, но ненасытный пожиратель команд и хладнокровный исполнитель инструкций. Можно привести грубый пример последовательности инструкций:</p><img src='img/n15.png' alt='sheme' class='sheme'><p class='simple-text'>В результате исполнения такой последовательности инструкций на экран будет выведена паническая фраза «АААА!».</p><p class='simple-text'>Довольно много кода для такой простой цели! Понятно, что если бы все программы писались вот так, непосредственно, разработка сложных продуктов занимала бы века. А если ещё принять во внимание, что процессоры разрабатываются и производятся во множестве различных архитектур и систем команд (инструкций), то написание идентичной по алгоритму программы для процессоров различных архитектур и систем команд потребует многократного увеличения времени как на их изучение и освоение, так и непосредственно на написание собственного кода для каждого оригинального процессора.</p><h1 class='small-topic-2'>Зачем нужны языки программирования</h1><p class='simple-text'>Для решения двуединой задачи: упрощения написания и понимания программ человеком, а также для исключения зависимости исходного кода программы от 'железа' (от системы команд-инструкций конкретного процессора) были придуманы и созданы языки программирования. Их очень много и даже из тех что постоянно на слуху можно быстро вспомнить десяток-другой: Assembler, C, C++, C#, Java, Python, Ruby, PHP, Scala, JavaScript.</p><p class='simple-text'>Программы на этих языках гораздо ближе к естественному языку человека. Следовательно, их проще, быстрее и приятнее писать. И что самое главное, их гораздо проще читать: вам сразу после написания, вам через год или вашему коллеге.</p><p class='simple-text'>Проблема в том, что такие языки непонятны процессору, и перед тем, как дать ему эту программу на выполнение, её нужно транслировать (translate): перевести с естественного языка на язык процессора (на машинный язык). Трансляция-перевод может осуществляться непосредственно слово за словом (выражение за выражением) — это осуществляют программы-интерпретаторы языков (англ. interpreter — истолкователь). Их действие аналогично синхронному переводу, когда переводчики-синхронисты переводят фразы, выражающие законченный смысл, в темпе их произнесения или поступления. Трансляция-перевод может осуществляться и всего текста (листинга) программы целиком — это осуществляют программы-компиляторы (англ. compiler — составитель, собиратель). Их действие схоже с переводом обычных законченных текстов. У каждого языка, если только он не остался на уровне фантазий, есть свой транслятор-переводчик: либо интерпретатор либо компилятор, или и тот, и другой. Для популярных языков их обычно несколько на выбор, от разных производителей и для разных платформ. Большинство из них свободно доступно в интернете.</p><p class='simple-text'>Итак, есть программы на вполне понятном человеку языке: их ещё называют «исходным кодом», просто «кодом» или «исходниками». Они пишутся в простые текстовые файлы с помощью любого текстового редактора, хоть с помощью Notepad. Затем они превращаются в понятные процессору наборы нулей и единиц с помощью транслятора (интерпретатора или компилятора), который интерпретирует исходный код и непосредственно выполняет заключённые в нём инструкции, используя ресурсы процессора, а компилятор получает на вход исходный код, а на выходе создаёт бинарный (двоичный) исполняемый файл, тот самый, который понятен процессору и называется исполняемой программой.</p><p class='simple-text'>Бинарные файлы непригодны для чтения людьми и предназначены, в общем, лишь для исполнения процессором. Они могут иметь разный тип в зависимости от того, для чего получены: .exe — это файл исполняемой программы для операционной системы Windows, .hex — это файл исполняемой программы, приготовленный для загрузки на выполнение микроконтроллером типа Arduino, т. е. для выполнения практически на «чистом железе» (без ОС и прочих системных программ).</p><p class='simple-text'>Почему же существует столько языков программирования и в чём разница?</p><p class='simple-text'>Почему? Потому что на Земле много людей и компаний, и многие считали, что могут сделать лучше всех: удобнее, понятнее, быстрее, стройнее.</p><p class='simple-text'>В чём разница: разные языки — это разный баланс скорости написания, понятности при чтении и скорости исполнения.</p><p class='simple-text'>Посмотрим на одну и ту же программу, которая выводит на экран песенку про 99 бутылок пива на разных языках программирования.</p><p class='simple-text'>Например, язык Perl. Пишется быстро; понять, что имел в виду программист невозможно; исполняется медленно:</p><img src='img/n9.png' alt='sheme' class='sheme'><p class='simple-text'>Язык Java. Пишется относительно долго; читается просто; исполняется довольно быстро, но занимает много памяти:</p><img src='img/n10.png' alt='sheme' class='sheme'><p class='simple-text'>Язык Assembler. Пишется долго; читается сложно; исполняется очень быстро:</p><img src='img/n11.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>На чём программируется Arduino</h1><p class='simple-text'>Если говорить об Arduino или о микроконтроллерах компании Atmel, на каком языке можно писать программы для них? Теоретический ответ: на любом. Но на практике выбор ограничивается языками Assembler, C и C++. Это связанно с тем, что в сравнении с настольным компьютером у них очень ограниченные ресурсы. Килобайты памяти, а не гигабайты. Мегагерцы на процессоре, а не гигагерцы. Это плата за дешевизну и энергоэффективность.</p><p class='simple-text'>Поэтому нужен язык, который может компилироваться и исполняться эффективно. То есть переводиться в те самые нули и единицы из инструкций как можно оптимальнее, без расходов драгоценных инструкций и памяти впустую. Подобной эффективностью как раз и обладают названные языки. Используя их, даже в узких рамках ресурсов микроконтроллера можно писать богатые возможностями программы, которые работают быстро.</p><p class='simple-text'>Assembler, как вы видели, нельзя назвать самым простым и элегантным и, естественно, как результат, флагманским языком для Arduino является C/C++.</p><p class='simple-text'>Во многих источниках говорится, что Arduino программируется на особом языке: Processing, Wiring. Это не совсем корректное утверждение. Контроллер программируется на C/C++, а то, что называется этими словами — это просто удобный «обвес», который позволяет решать многие типичные задачи, скрывая частности и детали, да не изобретая велосипед каждый раз.</p><p class='simple-text'>Почему C и C++ упоминаются в одном предложении? C++ — это надстройка над C. Всякая программа на C является корректной программой для C++, но не наоборот. Вы можете пользоваться и тем, и другим. Чаще всего вы даже не будете задумываться о том, что используете, решая текущую задачу.</p><h1 class='small-topic-2'>Ближе к делу: первая программа</h1><p class='simple-text'>Давайте напишем первую программу для Arduino и заставим плату её исполнять. Вам необходимо создать текстовый файл с исходным кодом, скомпилировать его и подсунуть полученный бинарный файл микроконтроллеру на плате.</p><p class='simple-text'>Пойдём по порядку. Напишем исходный код. Можно написать его в блокноте или любом другом редакторе. Однако для того, чтобы работа была удобной, существуют так называемые среды разработки (IDE, Integrated Development Environment). Они в виде единого инструмента предоставляют и текстовый редактор с подсветкой и подсказками, и компилятор, запускаемый по кнопке, и много других радостей. Для ардуинок такая среда называется Arduino IDE. Она свободно доступна для скачивания на нашем сайте.</p><p class='simple-text'>Установите среду и запустите её. В появившемся окне вы увидите, что большая часть места отдана текстовому редактору. В него и пишется код. Код в мире Arduino ещё называют скетчем (англ. sketch — набросок, эскиз). К слову, «скетч» как имя нарицательное пришло в мир искусства программирования из мира искусства и художников.</p><p class='simple-text'>Итак, давайте напишем скетч (набросаем эскиз), который ничего не делает. То есть минимально возможную правильную программу на C++, которая просто прожигает время.</p><img src='img/n12.png' alt='sheme' class='sheme'><p class='simple-text'>Не будем пока заострять внимание на значении написанного кода. Скомпилируем его. Для этого в Arduino IDE на панели инструментов есть кнопка «Verify». Нажмите её, и через несколько секунд бинарный файл будет готов. Об этом возвестит надпись «Done compiling» под текстовым редактором.</p><img src='img/n13.png' alt='sheme' class='sheme'><p class='simple-text'>В результате у нас получился бинарный файл с расширением .hex, который может исполнять микроконтроллер.</p><p class='simple-text'>Теперь необходимо подсунуть его контроллеру. Этот процесс называется загрузкой, прошивкой или заливкой. Для загрузки полученной программы на устройство в среде Arduino IDE есть кнопка «Upload» на панели инструментов. Соедините вашу плату с компьютером через USB-кабель, нажмите «Upload», и через несколько мгновений программа будет загружена в ардуинку. При этом программа, которая была в контроллере ранее, будет стёрта.</p><p class='simple-text'>Об успешной прошивке возвестит надпись «Done Uploading».</p><img src='img/n14.png' alt='sheme' class='sheme'><p class='simple-text'>Если при попытке загрузки вы столкнулись с ошибкой убедитесь, что:</p><p class='simple-text'>1. В меню Tools → Board выбран тот порт, к которому действительно подключена Arduino. Можете вынуть и вставить пару-тройку раз USB-кабель, чтобы понять какой порт появляется и исчезает: это и есть ваша плата.</p><p class='simple-text'>2. Вы установили необходимые драйверы для вашей платы. Это необходимо для Windows, не требуется под Linux и необходимо только для старых плат на MacOS.</p><p class='simple-text pad-bot'>Поздравляем! Вы прошли весь путь от чистого листа до работающей на контроллере программы. Пусть она ничего и не делает, но это уже успех.</p></aside>"
    },
    {
        "title": "Структура программы на языке C++ для Arduino",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Структура программы на языке C++ для Arduino</h1><p class='simple-text'>Рассмотрим пример минимально возможной программы на C++ для Arduino, которая ничего не делает:</p><img src='img/n15.png' alt='sheme' class='sheme'><p class='simple-text'>Разберёмся что здесь написано и почему это обязательно: почему нельзя обойтись просто пустым файлом.</p><h1 class='small-topic-2'>Из чего состоит программа</h1><p class='simple-text'>Для начала стоит понять, что программу нельзя читать и писать как книгу: от корки до корки, сверху вниз, строку за строкой. Любая программа состоит из отдельных блоков. Начало блока кода в C/C++ обозначается левой фигурной скобкой {, его конец — правой фигурной скобкой }.</p><p class='simple-text'>Блоки бывают разных видов и какой из них когда будет исполняться зависит от внешних условий. В примере минимальной программы вы можете видеть 2 блока. В этом примере блоки называются определением функции. Функция — это просто блок кода с заданным именем, которым кто-то затем может пользоваться из-вне.</p><p class='simple-text'>В данном случае у нас 2 функции с именами setup и loop. Их присутствие обязательно в любой программе на C++ для Arduino. Они могут ничего и не делать, как в нашем случае, но должны быть написаны. Иначе на стадии компиляции вы получите ошибку.</p><h1 class='small-topic-2'>Классика жанра: мигающий светодиод</h1><p class='simple-text'>Давайте теперь дополним нашу программу так, чтобы происходило хоть что-то. На Arduino, к 13-му пину подключён светодиод. Им можно управлять, чем мы и займёмся.</p><img src='img/n16.png' alt='sheme' class='sheme'><p class='simple-text'>Скомпилируйте, загрузите программу. Вы увидите, что каждую секунду светодиод на плате помигивает. Разберёмся почему этот код приводит к ежесекундному миганию.</p><p class='simple-text'>В наши ранее пустые функции мы добавили несколько выражений. Они были размещены между фигурными скобками функций setup и loop. В setup появилось одно выражение, а в loop сразу 4.</p><p class='simple-text'>Каждое выражение — это приказ процессору сделать нечто. Выражения в рамках одного блока исполняются одно за другим, строго по порядку без всяких пауз и переключений. То есть, если мы говорим об одном конкретном блоке кода, его можно читать сверху вниз, чтобы понять что делается.</p><p class='simple-text'>Теперь давайте поймём в каком порядке исполняются сами блоки, т.е. функции setup и loop. Не задумывайтесь пока что значат конкретные выражения, просто понаблюдайте за порядком.</p><p class='simple-text'>Как только Arduino включается, перепрошивается или нажимается кнопка RESET, «нечто» вызывает функцию setup. То есть заставляет исполняться выражения в ней.</p><p class='simple-text'>Как только работа setup завершается, сразу же «нечто» вызывает функцию loop.</p><p class='simple-text'>Как только работа loop завершается, сразу же «нечто» вызывает функцию loop ещё раз и так до бесконечности.</p><p class='simple-text'>Если пронумеровать выражения по порядку, как они исполняются, получится:</p><img src='img/n17.png' alt='sheme' class='sheme'><p class='simple-text'>Ещё раз напомним, что не стоит пытаться воспринимать всю программу, читая сверху вниз. Сверху вниз читается только содержимое блоков. Мы вообще можем поменять порядок объявлений setup и loop.</p><img src='img/n18.png' alt='sheme' class='sheme'><p class='simple-text'>Результат от этого не изменится ни на йоту: после компиляции вы получите абсолютно эквивалентный бинарный файл.</p><h1 class='small-topic-2'>Что делают выражения</h1><p class='simple-text'>Теперь давайте попробуем понять почему написанная программа приводит в итоге к миганию светодиода.</p><p class='simple-text'>Как известно, пины Arduino могут работать и как выходы и как входы. Когда мы хотим чем-то управлять, то есть выдавать сигнал, нам нужно перевести управляющий пин в состояние работы на выход. В нашем примере мы управляем светодиодом на 13-м пине, поэтому 13-й пин перед использованием нужно сделать выходом.</p><p class='simple-text'>Это делается выражением в функции setup:</p><img src='img/n19.png' alt='sheme' class='sheme'><p class='simple-text'>Выражения бывают разными: арифметическими, декларациями, определениями, условными и т.д. В данном случае мы в выражении осуществляем вызов функции. Помните? У нас есть свои функции setup и loop, которые вызываются чем-то, что мы назвали «нечто». Так вот теперь мы вызываем функции, которые уже написаны где-то.</p><p class='simple-text'>Конкретно в нашем setup мы вызываем функцию с именем pinMode. Она устанавливает заданный по номеру пин в заданный режим: вход или выход. О каком пине и о каком режиме идёт речь указывается нами в круглых скобках, через запятую, сразу после имени функции. В нашем случае мы хотим, чтобы 13-й пин работал как выход. OUTPUT означает выход, INPUT — вход.</p><p class='simple-text'>Уточняющие значения, такие как 13 и OUTPUT называются аргументами функции. </p><p class='simple-text'>Совершенно не обязательно, что у всех функций должно быть по 2 аргумента. Сколько у функции аргументов зависит от сути функции, от того как её написал автор. Могут быть функции с одним аргументом, тремя, двадцатью; функции могут быть без аргументов вовсе. Тогда для их вызова круглые скобка открывается и тут же закрывается:</p><img src='img/n20.png' alt='sheme' class='sheme'><p class='simple-text'>На самом деле, вы могли заметить, наши функции setup и loop также не принимают никакие аргументы. И загадочное «нечто» точно так же вызывает их с пустыми скобками в нужный момент.</p><p class='simple-text'>Вернёмся к нашему коду. Итак, поскольку мы планируем вечно мигать светодиодом, управляющий пин должен один раз быть сделан выходом и затем мы не хотим вспоминать об этом. Для этого идеологически и предназначена функция setup: настроить плату как нужно, чтобы затем с ней работать.</p><p class='simple-text'>Перейдём к функции loop:</p><img src='img/n21.png' alt='sheme' class='sheme'><p class='simple-text'>Она, как говорилось, вызывается сразу после setup. И вызывается снова и снова как только сама заканчивается. Функция loop называется основным циклом программы и идеологически предназначена для выполнения полезной работы. В нашем случае полезная работа — мигание светодиодом.</p><p class='simple-text'>Пройдёмся по выражениям по порядку. Итак, первое выражение — это вызов встроенной функции digitalWrite. Она предназначена для подачи на заданный пин логического нуля (LOW, 0 вольт) или логической единицы (HIGH, 5 вольт) В функцию digitalWrite передаётся 2 аргумента: номер пина и логическое значение. В итоге, первым делом мы зажигаем светодиод на 13-м пине, подавая на него 5 вольт.</p><p class='simple-text'>Как только это сделано процессор моментально приступает к следующему выражению. У нас это вызов функции delay. Функция delay — это, опять же, встроенная функция, которая заставляет процессор уснуть на определённое время. Она принимает всего один аргумент: время в миллисекундах, которое следует спать. В нашем случае это 100 мс.</p><p class='simple-text'>Пока мы спим всё остаётся как есть, т.е. светодиод продолжает гореть. Как только 100 мс истекают, процессор просыпается и тут же переходит к следующему выражению. В нашем примере это снова вызов знакомой нам встроенной функции digitalWrite. Правда на этот раз вторым аргументом мы передаём значение LOW. То есть устанавливаем на 13-м пине логический ноль, то есть подаём 0 вольт, то есть гасим светодиод.</p><p class='simple-text'>После того, как светодиод погашен мы приступаем к следующему выражению. И снова это вызов функции delay. На этот раз мы засыпаем на 900 мс.</p><p class='simple-text'>Как только сон окончен, функция loop завершается. По факту завершения «нечто» тут же вызывает её ещё раз и всё происходит снова: светодиод поджигается, горит, гаснет, ждёт и т.д.</p><p class='simple-text'>Если перевести написанное на русский, получится следующий алгоритм:</p><p class='simple-text'>1. Поджигаем светодиод</p><p class='simple-text'>2. Спим 100 миллисекунд</p><p class='simple-text'>3. Гасим светодиод</p><p class='simple-text'>4. Спим 900 миллисекунд</p><p class='simple-text'>5. Переходим к пункту 1</p><p class='simple-text'>Таким образом мы получили Arduino с маячком, мигающим каждые 100 + 900 мс = 1000 мс = 1 сек.</p><h1 class='small-topic-2'>Что можно изменить</h1><p class='simple-text'>Давайте пользуясь только полученными знаниями сделаем несколько вариаций программы, чтобы лучше понять принцип.</p><p class='simple-text'>Вы можете подключить внешний светодиод или другое устройство, которым нужно «мигать» на другой пин. Например, на 5-й. Как в этом случае должна измениться программа? Мы должны всюду, где обращались к 13-му пину заменить номер на 5-й:</p><img src='img/n22.png' alt='sheme' class='sheme'><p class='simple-text'>Компилируйте, загружайте, проверяйте.</p><p class='simple-text'>Что нужно сделать, чтобы светодиод мигал 2 раза в секунду? Уменьшить время сна так, чтобы в сумме получилось 500 мс:</p><img src='img/n23.png' alt='sheme' class='sheme'><p class='simple-text'>Как сделать так, чтобы светодиод при каждом «подмигивании» мерцал дважды? Нужно поджигать его дважды с небольшой паузой между включениями:</p><img src='img/n24.png' alt='sheme' class='sheme'><p class='simple-text'>Как сделать так, чтобы в устройстве были 2 светодиода, которые мигали бы каждую секунду поочерёдно? Нужно общаться с двумя пинами и работать в loop то с одним, то с другим:</p><img src='img/n25.png' alt='sheme' class='sheme'><p class='simple-text'>Как сделать так, чтобы в устройстве были 2 светодиода, которые переключались бы на манер железнодорожного светофора: горел бы то один то другой? Нужно просто не выключать горящий светодиод тут же, а дожидаться момента переключения:</p><img src='img/n26.png' alt='sheme' class='sheme'><p class='simple-text'>Можете проверить другие идеи самостоятельно. Как видите, всё просто!</p><h1 class='small-topic-2'>О пустом месте и красивом коде</h1><p class='simple-text'>В языке C++ пробелы, переносы строк, символы табуляции не имеют большого значения для компилятора. Там где стоит пробел, может быть перенос строки и наоборот. На самом деле 10 пробелов подряд, 2 переноса строки и ещё 5 пробелов — это всё эквивалент одного пробела.</p><p class='simple-text'>Пустое пространство — это инструмент программиста, с помощью которого можно или сделать программу понятной и наглядной, или изуродовать до неузнаваемости. Например, вспомним программу для мигания светодиодом:</p><img src='img/n27.png' alt='sheme' class='sheme'><p class='simple-text'>Мы можем изменить её так:</p><img src='img/n28.png' alt='sheme' class='sheme'><p class='simple-text'>Всё, что мы сделали — немного «поработали» с пустым пространством. Теперь можно наглядно видеть разницу между стройным кодом и нечитаемым.</p><p class='simple-text'>Чтобы следовать негласному закону оформления программ, который уважается на форумах, при чтении другими людьми, легко воспринимается вами же, следуйте нескольким простым правилам:</p><p class='simple-text'>1. Всегда, при начале нового блока между { и } увеличивайте отступ. Обычно используют 2 или 4 пробела. Выберите одно из значений и придерживайтесь его всюду.</p><p class='simple-text'>Плохо:</p><img src='img/n29.png' alt='sheme' class='sheme'><p class='simple-text'>Хорошо:</p><img src='img/n30.png' alt='sheme' class='sheme'><p class='simple-text'>2. Как и в естественном языке: ставьте пробел после запятых и не ставьте до.</p><p class='simple-text'>Плохо:</p><img src='img/n31.png' alt='sheme' class='sheme'><p class='simple-text'>Хорошо:</p><img src='img/n32.png' alt='sheme' class='sheme'><p class='simple-text'>3. Размещайте символ начала блока { на новой строке на текущем уровне отступа или в конце предыдущей. А символ конца блока } на отдельной строке на текущем уровне отступа:</p><p class='simple-text'>Плохо:</p><img src='img/n33.png' alt='sheme' class='sheme'><p class='simple-text'>Хорошо:</p><img src='img/n34.png' alt='sheme' class='sheme'><p class='simple-text'>4. Используйте пустые строки для разделения смысловых блоков:</p><p class='simple-text'>Хорошо:</p><img src='img/n35.png' alt='sheme' class='sheme'><p class='simple-text'>Ещё лучше:</p><img src='img/n36.png' alt='sheme' class='sheme'><p class='simple-text'>Вы могли заинтересоваться: зачем в конце каждого выражения ставится точка с запятой? Таковы правила C++. Подобные правила называются синтаксисом языка. По символу ; компилятор понимает где заканчивается выражение.</p><p class='simple-text'>Как уже говорилось, переносы строк для него — пустой звук, поэтому ориентируется он на этот знак препинания. Это позволяет записывать сразу несколько выражений в одной строке:</p><img src='img/n37.png' alt='sheme' class='sheme'><p class='simple-text'>Программа корректна и эквивалентна тому, что мы уже видели. Однако писать так — это дурной тон. Код гораздо сложнее читается. Поэтому если у вас нет 100% веских причин писать в одной строке несколько выражений, не делайте этого.</p><h1 class='small-topic-2'>О комментариях</h1><p class='simple-text'>Одно из правил качественного программирования: «пишите код так, чтобы он был настолько понятным, что не нуждался бы в пояснениях». Это возможно, но не всегда. Для того, чтобы пояснить какие-то не очевидные моменты в коде его читателям: вашим коллегам или вам самому через месяц, существуют так называемые комментарии.</p><p class='simple-text'>Это конструкции в программном коде, которые полностью игнорируются компилятором и имеют значение только для читателя. Комментарии могут быть многострочными или однострочными:</p><img src='img/n38.png' alt='sheme' class='sheme'><p class='simple-text'>Как видите, между символами /* и */ можно писать сколько угодно строк комментариев. А после последовательности // комментарием считается всё, что следует до конца строки.</p><p class='simple-text pad-bot'>Итак, надеемся самые основные принципы составления написания программ стали понятны. Полученные знания позволяют программно управлять подачей питания на пины Arduino по определённым временны́м схемам. Это не так уж много, но всё же достаточно для первых экспериментов.</p></aside>"
    },
    {
        "title": "Константы, переменные и арифметика",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Константы, переменные и арифметика</h1><p class='simple-text'>Рассмотрим пример кода «железнодорожного светофора», то есть программу, которая заставляет поочерёдно мигать два светодиода:</p><img src='img/n39.png' alt='sheme' class='sheme'><p class='simple-text'>Как видно, предполагается, что светодиоды подключаются к пинам 5 и 6 на Arduino, а переключение происходит раз в 1000 миллисекунд, т.е. ежесекундно.</p><p class='simple-text'>Представьте теперь, что в силу обстоятельств, стало необходимо перенести светодиоды с этих пинов на 12-й и 13-й пины. К тому же стало понятно, что устройство смотрится лучше при переключении не раз в секунду, а раз в 2 секунды. Что делать?</p><p class='simple-text'>Можно модифицировать программу и всюду, где речь шла о 5-м пине, использовать 12-й; 6-й пин заменить на 13-й, а в функциях delay изменить задержку с 1000 на 2000.</p><img src='img/n40.png' alt='sheme' class='sheme'><p class='simple-text'>Теперь программа работает как нужно, но для того, чтобы проделать эти небольшие изменения, нам пришлось так или иначе изменить абсолютно все строки в наших функциях!</p><p class='simple-text'>В данном случае мы имеем дело с довольно простой программой и проделать изменения не так сложно. Но что если устройство довольно сложное и скетч расписан на сотни строк?! В этом случае сделать все изменения правильно, не ошибиться и не пропустить ни одного изменения становится крайне сложно: мы люди и нам свойственно ошибаться из-за невнимательности.</p><p class='simple-text'>Кроме того, если устройство управляет кучей индикаторов, моторов, считывает данные с нескольких сенсоров, запоминать что к какому пину подключено становится сложно. При чтении сложной программы, когда видим вызов digitalWrite(4, HIGH), понять имели ли мы в виду включение светодиода или остановку двигателя, или что-то ещё уже не так просто. Что можно сделать, чтобы решить проблему?</p><h1 class='small-topic-2'>Макроопределения</h1><p class='simple-text'>Мы можем единожды указать, что левый светодиод — это пин 13, правый — пин 12, а переключать состояния нужно каждые X миллисекунд. Для этого каждому значению назначается понятное имя, которое затем и используется для обращения:</p><img src='img/n41.png' alt='sheme' class='sheme'><p class='simple-text'>Всё, теперь для изменения параметров устройства достаточно изменить нужные значения в начале программы и не думать об изменениях в самой логике. Кроме того выражение вроде digitalWrite(RIGHT_LED, LOW) гораздо более информативно нежели digitalWrite(12, LOW) и даёт чёткое понимание того, что имел в виду автор.</p><p class='simple-text'>Конструкция #define называется макроопределением. Она говорит компилятору о том, что всякий раз, когда он видит указанное имя, стоит использовать на этом месте указанное значение.</p><p class='simple-text'>Обратите внимание: макроопределения #define не завершаются точкой с запятой в конце строки. Дело в том, что #define — это не обычное выражение, а так называемая препроцессорная директива. Подстановка конкретных значений вместо имён происходит ещё до компиляции, на стадии предварительной обработки исходного файла. На этой стадии, по сути, компилятор проделывает операцию как в текстовом редакторе: «Найти все и заменить». Просто результат этой операции не сохраняется в файл, а тут же им используется для непосредственной компиляции.</p><p class='simple-text'>Если бы вы поставили ; после #define, в результате обработки компилятор увидел бы такой код:</p><img src='img/n42.png' alt='sheme' class='sheme'><p class='simple-text'>Попытка скомпилировать такой скетч приведёт к ошибке.</p><p class='simple-text'>Встроенные макроопределения</p><p class='simple-text'>Вы могли догадаться, что уже знакомые нам значения HIGH, LOW, OUTPUT — это также не что иное как макроопределения. Просто #define для них написан в некотором другом месте и мы можем просто сразу ими пользоваться.</p><p class='simple-text'>На самом деле код мигания светодиодом:</p><img src='img/n43.png' alt='sheme' class='sheme'><p class='simple-text'>с точки зрения компилятора есть ни что иное как:</p><img src='img/n44.png' alt='sheme' class='sheme'><p class='simple-text'>Если вы откроете файл hardware/arduino/cores/arduino/Arduino.h в вашем дистрибутиве Arduino IDE, вы сможете увидеть, что HIGH — это макроопределение 1, LOW — 0, OUTPUT — 1 и т.д. Эти значения используются настолько часто, что они встроены таким образом.</p><p class='simple-text'>Использование понятных имён вместо магических чисел — это один из признаков профессионализма. Это делает код более понятным и простым для изменений, что всегда уважается.</p><p class='simple-text'>Об именах макроопределений</p><p class='simple-text'>По негласному соглашению все макроопределения должны иметь имена, написанные заглавными буквами с символом нижнего прочерка _ на месте пробелов.</p><img src='img/n45.png' alt='sheme' class='sheme'><p class='simple-text'>Это настолько привычное правило, что вы можете ввести в заблуждение других, если не будете его придерживаться. Опять же, следование общепринятым канонам — признак профи.</p><p class='simple-text'>Стоит отметить, что язык C++, как и многие другие считает строчные и заглавные буквы различными, поэтому если к макроопределению LED_PIN вы затем попытаетесь обратиться, написав led_pin будет выдана ошибка компилятора о том, что он не понимает что такое led_pin. То же самое касается имён функций и всего остального.</p><h1 class='small-topic-2'>Переменные</h1><p class='simple-text'>Макроопределения хороши для именования значений, которые не могут измениться по ходу выполнения программы. Мы вряд ли захотим на лету, без изменения кода и перезагрузки Arduino, перенести светодиод маячка с одного пина Arduino на другой. Но что делать, если какие-то параметры программы всё же должны изменяться с течением времени?</p><p class='simple-text'>Для этого существуют переменные — именованные значения, которые могут изменяться при исполнении программы процессором. Как и когда они должны изменяться зависит от вас, от того какой алгоритм вы задумали и как написали программу для этого.</p><p class='simple-text'>Например, давайте рассмотрим программу «помирающего маячка». Первый раз он мигает через 1000 мс, затем через 1100 мс, затем через 1200 мс и так далее до бесконечности:</p><img src='img/n46.png' alt='sheme' class='sheme'><p class='simple-text'>Вместо того, чтобы обозначить время до следующего подмигивания через макроопределение #define, мы использовали конструкцию:</p><img src='img/n47.png' alt='sheme' class='sheme'><p class='simple-text'>Это называется определением переменной. Мы таким образом заявили, что хотим иметь ячейку памяти, к которой будем обращаться по имени blinkDelay и изначально, при старте Arduino, в ней должно лежать значение 900.</p><p class='simple-text'>Перед именем переменной в определении указывается тип данных для этой переменной. В нашем случае — это int, что означает «целое число» (int — сокращение от английского «integer»: целочисленный).</p><p class='simple-text'>Обратите внимание: объявление переменной, в отличие от макроопределения — это обычное выражение, поэтому оно должно завершаться точкой с запятой.</p><p class='simple-text'>Итак, мы сообщили компилятору, что у нас есть переменная целочисленного типа, с именем blinkDelay и начальным значением 900. Теперь мы можем ей пользоваться.</p><p class='simple-text'>Пользоваться переменной можно в двух смыслах: получать её значение и изменять её значение. Получение значения выглядит ровно так же, как и использование макроопределений: мы просто используем её имя в коде, а в результате, при исполнении программы в действительности используется её значение:</p><img src='img/n48.png' alt='sheme' class='sheme'><p class='simple-text'>В нашей программе это выражение означает «уснуть на столько миллисекунд, сколько сейчас записано в переменной с именем blinkDelay». При первом исполнении этого выражения значение будет изначальным, таким образом мы уснём на 900 мс.</p><p class='simple-text'>Далее в нашем скетче мы можем видеть:</p><img src='img/n49.png' alt='sheme' class='sheme'><p class='simple-text'>Это так называемое арифметическое выражение (англ. expression). </p><p class='simple-text'>Символ += называется оператором и означает в C++ «увеличить на». Таким образом после исполнения этого выражения, значение переменной blinkDelay станет на сотню больше и сохранится в ней до следующего изменения.</p><p class='simple-text'>Как результат:</p><p class='simple-text'>При первом исполнении функции loop мы выжидаем с выключенным светодиодом 900 мс</p><p class='simple-text'>К началу второго исполнения blinkDelay уже равна 1000, поэтому мы будем выжидать 1000 мс</p><p class='simple-text'>При третьем исполнении мы будем выжидать 1100 мс</p><p class='simple-text'>…и так далее до бесконечности</p><p class='simple-text'>В итоге мы получаем что и хотели: «помирающий» маячок.</p><p class='simple-text'>Об именах переменных</p><p class='simple-text'>Как и в случае с макроопределениями существует общепринятая конвенция о том как нужно называть переменные. Их принято именовать в так называемом «верблюжьем стиле» (camelCase). То есть, начинать строчными буквами, а каждое новое слово писать слитно, с заглавной буквы.</p><img src='img/n50.png' alt='sheme' class='sheme'><p class='simple-text'>Также отличительным признаком профессионализма является использование понятных, лаконичных имён из которых чётко понятно зачем нужна конкретная переменная в программе.</p><p class='simple-text'>Ничто так не выносит мозг, как использование одно- или двухбуквенных имён без смысла или применение транслита.</p><img src='img/n51.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Составление арифметических выражений</h1><p class='simple-text'>В нашем примере мы использовали оператор += для увеличения целочисленного значения нашей переменной.</p><p class='simple-text'>Конечно же, это не единственный оператор в C++. Кроме того += — это так называемый синтаксический сахар (syntax sugar) — удобная и короткая запись полного выражения. На самом деле выражение:</p><img src='img/n52.png' alt='sheme' class='sheme'><p class='simple-text'>эквивалентно такой, полной записи:</p><img src='img/n53.png' alt='sheme' class='sheme'><p class='simple-text'>Не стоит воспринимать символ = дословно, как «равно». В C++ этот символ называется оператором присваивания или просто присваиванием. Нужно читать это выражение так: присвоить переменной blinkDelay (то, что слева от =) вычисленное значение blinkDelay + 100 (то, что справа от =).</p><p class='simple-text'>Вас не должно смущать, что blinkDelay упоминается и в левой и в правой части выражения. Опять же, это не означает «900 = 1000», это означает «записать в переменную blinkDelay новое значение: результат сложения текущего значения blinkDelay и числа 100.</p><p class='simple-text'>Зацикленная змейка</p><p class='simple-text'>В одном арифметическом выражении может быть сколько угодно операторов и участвовать сколько угодно переменных. Для демонстрации давайте напишем программу для устройства-гирлянды. Допустим, вы подключили к Arduino 10 светодиодов, к пинам с 4-го по 13-й и хотите, чтобы они включались поочерёдно, как бегущая змейка. Тогда скетч может выглядеть так:</p><img src='img/n54.png' alt='sheme' class='sheme'><p class='simple-text'>Да, код в setup выглядит несколько громоздко, но не будем пока заострять на нём внимание. Как сделать «правильно» будет показано при изучении понятия циклов. Сосредоточимся на функции loop.</p><p class='simple-text'>Первым делом мы поджигаем светодиод на пине номер которого записан в переменной ledPin. При старте программы, как видно из определения, ей присваивается значение FIRST_LED, которое в свою очередь мы определили как 4. То есть, при первом проходе loop мы зажигаем светодиод на 4-м пине.Первым делом мы поджигаем светодиод на пине номер которого записан в переменной ledPin. При старте программы, как видно из определения, ей присваивается значение FIRST_LED, которое в свою очередь мы определили как 4. То есть, при первом проходе loop мы зажигаем светодиод на 4-м пине.</p><p class='simple-text'>Далее мы выжидаем 100 мс и выключаем его.</p><p class='simple-text'>Затем нам нужно переписать значение ledPin, чтобы к следующему проходу основного цикла она приняла значение следующего по порядку пина. При этом, если текущий пин был последним, т.е. 13-м, следующий за ним должен быть 4-й, чтобы всё началось заново. Всё это делается с помощью арифметического выражения:</p><img src='img/n55.png' alt='sheme' class='sheme'><p class='simple-text'>Давайте поймём что здесь происходит. Выражение даёт предписание процессору присвоить переменной ledPin вычисленное значение выражения, стоящего справа от =. В этом выражении используются операторы -, +, %, скобки, текущее значение переменной ledPin, макроопределения FIRST_LED и TOTAL_LEDS.</p><p class='simple-text'>Итоговое значение вычисляется по тем же правилам, что и в обычной математике: сначала то, что в скобках; затем умножение и деление; и наконец, сложение и вычитание. В языке C++ символ % — это оператор «модуло» или оператор остатка от деления:</p><p class='simple-text'>Вернёмся к нашему выражению. Если развернуть его для первого прохода loop, получится:</p><p class='simple-text'>(4 - 4 + 1) % 10 + 4 = (1) % 10 + 4 = 1 + 4 = 5</p><p class='simple-text'>То есть, после четвёртого пина переменная ledPin примет значение 5-го.</p><p class='simple-text'>Аналогично, после 5-го последует 6-й, после 6-го — 7-й и так далее до 13-го. Теперь давайте посмотрим что присвоится переменной ledPin, если на текущем проходе она равна 13, то есть мы только что мигнули последним светодиодом нашей змейки:</p><p class='simple-text'>(13 - 4 + 1) % 10 + 4 = (10) % 10 + 4 = 0 + 4 = 4</p><p class='simple-text'>Таким образом после 13-го пина снова последует 4-й, а это то, что нам нужно! Оператор остатка от деления часто используют как раз для зацикливания чего-либо.</p><p class='simple-text'>Пульсирующий маячок</p><p class='simple-text'>Давайте теперь напишем программу для пульсирующего маячка: светодиода, который поочерёдно то набирает яркость от нуля до максимума, то так же плавно гаснет до нуля. Скетч для этого может выглядеть так:</p><img src='img/n56.png' alt='sheme' class='sheme'><p class='simple-text'>Давайте разберёмся что здесь происходит. Мы определили 3 переменные: step, sign, brightness. При этом начальное значение присвоили только переменным step и brightness.</p><p class='simple-text'>В C++ можно не указывать начальное значение. В этом случае переменная при появлении примет значение абстрактного мусора: случайного значения, оставшегося в памяти от прошлой программы. Если по нашему замыслу перед чтением переменной мы точно сначала установим её значение — это не проблема.</p><p class='simple-text'>В первой строке loop мы использовали функцию analogWrite, а не digitalWrite, как делали раньше. analogWrite не просто выдаёт логический ноль или единицу на заданный пин, а выдаёт на него ШИМ-сигнал (PWM signal). То есть, пин начинает очень быстро (32 000 раз в секунду) переключаться между 0 и 5 вольтами и если подключить к такому пину светодиод, создастся иллюзия, что он горит в пол силы.</p><p class='simple-text'>Функция analogWrite принимает 2 аргумента: пин, о котором идёт речь и значение скважности. Значение скважности — это целое число от 0 до 255, которое определяет отношение длительности ступеньки в 0 В к длительности ступеньки в 5 В. Например:</p><p class='simple-text'>0 — это всегда 0 В (светодиод не горит)</p><p class='simple-text'>64 — это четверть времени 5 В и три четверти — 0 В (свечение в четверть силы)</p><p class='simple-text'>128 — это половина времени 5 В и половина 0 В (свечение в пол силы)</p><p class='simple-text'>255 — это всегда 5 В (свечение в полную силу)</p><p class='simple-text'>Как известно, не все пины Arduino поддерживают ШИМ. Нужно выбрать тот, который отмечен символом ~ на плате. Мы выбрали 5-й, что и определили именем LED_PIN.</p><p class='simple-text'>Ещё раз взглянем на наш loop:</p><img src='img/n57.png' alt='sheme' class='sheme'><p class='simple-text'>В переменной step мы хотим хранить порядковый номер прохождения функции loop: 1, 2, 3, …, 2345, 2346 и т.д. При её определении мы присвоили начальное значение 0 и хотим, чтобы оно увеличивалось каждый вызов loop. Это мы и делаем в первом выражении. Символ ++ означает в C++ оператор инкремента, оператор, который увеличивает значение на единицу. Теперь вы догадываетесь откуда взялось название языка «C++», надстроенного над «C». Оператор инкремента можно ставить как перед переменной, так и после. </p><p class='simple-text'>Следующие строки эквивалентны:</p><img src='img/n58.png' alt='sheme' class='sheme'><p class='simple-text'>В третьей строке основного цикла мы вычисляем и присваиваем новое значение переменной sign. Как видите, оно рассчитывается на основе значения другой переменной step.</p><p class='simple-text'>В C++ символ / означает оператор деления. Поскольку мы оперируем целыми числами оператор деления всегда отсекает дробную часть.</p><p class='simple-text'>Таким образом значение step / 256 будет становиться больше на единицу всякий раз, когда происходит 256 вызовов loop. Из этого значения мы дополнительно берём остаток от деления на 2. В итоге, значение sign будет становится поочерёдно то единицей, то нулём, переключаясь каждые 256 вызовов loop.</p><p class='simple-text'>Далее идёт, вероятно, немного пугающая по началу конструкция:</p><img src='img/n59.png' alt='sheme' class='sheme'><p class='simple-text'>Это на самом деле обычное арифметическое выражение, в котором мы вычисляем и присваиваем новое значение переменной brightness. Символы ? и : в C++ называются тернарным условным оператором. Его суть такова:</p><p class='simple-text'>Выражение, стоящее перед символом ? называется условием. В нашем случае всё условное выражение — это просто переменная sign</p><p class='simple-text'>Если значение условия не равно нулю, результатом оператора является выражение, стоящее между символами ? и :</p><p class='simple-text'>Если значение условия равно нулю, результатом оператора является выражение, стоящее после символа :</p><p class='simple-text'>То есть тернарный оператор образует выражение, в котором участвуют 3 подвыражения: условие, «что если не ноль» и «что если ноль». Если рассматривать наш пример, то:</p><p class='simple-text'>Если только что посчитанный sign — не ноль, brightness примет значение выражения brightness + 1</p><p class='simple-text'>А если sign — ноль, brightness примет значение выражения brightness - 1</p><p class='simple-text'>Таким образом, если вспомнить о том, как ведёт себя sign в нашем алгоритме, brightness будет рассчитываться то по одной формуле, то по другой. Сама формула переключается как и sign, каждые 256 циклов.</p><p class='simple-text'>Первая формула — увеличение brightness на единицу</p><p class='simple-text'>Вторая формула — уменьшение brightness на единицу</p><p class='simple-text'>В итоге, brightness с начала программы, с каждым новым loop будет то расти от 0 до 255, то уменьшаться обратно от 255 до 0. А это то, что нам нужно!</p><p class='simple-text'>Нам остаётся лишь чуть задержаться, чтобы дать светодиоду посветиться на текущем уровне яркости. В примере сделана задержка на 5 мс. Вы можете легко посчитать: при таком значении полное нарастание или затухание занимает 5 мс × 256 = 1280 мс.</p><h1 class='small-topic-2'>О компактной записи и области видимости</h1><p class='simple-text'>В примере с маячком мы объявляли переменную sign рядом с остальными. Однако на самом деле мы использовали её исключительно как временную, вспомогательную переменную для вычисления brightness. Мы рассчитывали её каждый раз непосредственно перед вычислением brightness и она не зависела от собственного значения на предыдущем проходе loop.</p><p class='simple-text'>При программировании потребность в таких временных переменных «на выброс» возникает очень часто. Для плюс-минус сложных устройств в скетче вам могут понадобиться десятки или сотни таких переменных. Представьте себе, что все они будут определены в одном месте большим рулоном.</p><p class='simple-text'>Разобраться в том, какая переменная для чего предназначена, будет крайне сложно. Для решения этой и других проблем в C++ переменные могут объявляться непосредственно в том месте, где используются.</p><p class='simple-text'>Если применить это к нашему примеру, получится такой код:</p><img src='img/n60.png' alt='sheme' class='sheme'><p class='simple-text'>Как видите, переменная sign теперь определяется непосредственно в том месте, где начинает использоваться.</p><p class='simple-text'>Мы не можем сделать то же самое с step и brightness, т.к. в этом случае, при каждом новом вызове loop они будут создаваться заново, а потому не сохранят своё значение с предыдущего прохода loop. Что касается sign — это не важно: мы всё равно каждый loop рассчитываем её заново.</p><p class='simple-text'>Любая объявленная переменная «живёт» только в рамках того блока кода {…}, где она определена. Это называется областью видимости (scope). Попытка использовать переменную sign из другой функции, например из setup приведёт к ошибке компиляции: мы объявили её в рамках loop, поэтому использовать её можем только там.</p><p class='simple-text'>Переменные объявленные вне функций, такие как step и brightness называются глобальными переменными. Они инициализируются в самом начале исполнения программы и доступны в скетче отовсюду.</p><p class='simple-text'>Встраивание выражений</p><p class='simple-text'>Если снова посмотреть на наш пример можно увидеть, что мы рассчитываем sign с помощью довольно простого выражения, а затем используем всего в одном месте, при расчёте brightness на следующей строке.</p><p class='simple-text'>В таких случаях можно встроить арифметическое выражение непосредственно в то место, где используется его результат и обойтись без отдельной промежуточной переменной вовсе:</p><img src='img/n61.png' alt='sheme' class='sheme'><p class='simple-text'>По итогам компиляции мы получим абсолютно идентичный результат. Мы просто написали то же самое, но другими словами. Промежуточная переменная всё равно будет создана, но это уже закадровая работа компилятора и нам не стоит об этом задумываться.</p><p class='simple-text'>Не стоит злоупотреблять подобным склеиванием чрезмерно: код может потерять стройность и понятность. Но для простых случаев, как наш, это вполне уместно.</p><p class='simple-text'>Кроме такого встраивания, выражения вообще можно составлять при вызове функции, на месте соответствующего аргумента. Если воспользоваться этим для нашего кода, получится вот такая сверхкомпактная запись:</p><img src='img/n62.png' alt='sheme' class='sheme'><p class='simple-text'>Да, это весь наш loop и он делает всё то же самое, что и раньше. Конструкция с analogWrite находится уже на грани читаемости, но для демонстрации вполне подходит. Разберёмся что же здесь написано.</p><p class='simple-text'>Компилятор видит, что мы вызываем функцию analogWrite. Он знает, что для неё нужно 2 аргумента и ищет их в круглых скобках. С первым аргументом, LED_PIN всё понятно. Это просто 5. Но на месте второго аргумента компилятор видит выражение. Поэтому перед непосредственным вызовом, значение выражения вычисляется и уже результат используется в качестве аргумента.</p><p class='simple-text'>В нашем случае на месте второго аргумента стоит тернарное выражение, поэтому первым делом вычисляется условие, то что стоит перед символом ?. Там мы видим: step++ / 256 % 2. Всё так же, как и раньше, но к step добавлен оператор инкремента ++. Всё вместе это означает:</p><p class='simple-text'>1. Взять значение step и запомнить его</p><p class='simple-text'>2. Увеличить значение step на единицу</p><p class='simple-text'>3. Целочисленно разделить запомненное в пункте (1) значение на 256</p><p class='simple-text'>4. Взять остаток от деления результата на 2</p><p class='simple-text'>То есть мы мало того, что встроили тернарное выражение прямо в вызов функции, мы ещё и операцию по увеличению step на единицу каждый loop разместили там же.</p><p class='simple-text'>Обратите внимание, что если оператор ++ расположен после имени переменной, то в расчёте значения арифметического значения выражения используется старое значение этой переменной: то, что было до увеличения на единицу.</p><img src='img/n63.png' alt='sheme' class='sheme'><p class='simple-text'>Если ++ стоял бы перед переменной, то она сначала увеличилась бы на единицу и только затем участвовала в вычислениях:</p><img src='img/n64.png' alt='sheme' class='sheme'><p class='simple-text'>Вернёмся к нашему вызову:</p><img src='img/n65.png' alt='sheme' class='sheme'><p class='simple-text'>С расчётом условия теперь всё понятно. Далее, как уже говорилось об операторе ? :, в случае если условие не оказалось равным нулю, берётся значение выражения между символами ? и :. В нашем случае — это brightness++. То есть, если условие с step оказалось не равным нулю, функция analogWrite в качестве аргумента получит значение выражения brightness++.</p><p class='simple-text'>Как уже говорилось, выражение brightness++ означает: «использовать текущее значение, но сразу после использования увеличить его на 1».</p><p class='simple-text'>Аналогичная ситуация со сценарием, когда условие оказывается равным нулю. Просто вместо оператора инкремента ++, мы используем оператор декремента – для уменьшения значения на единицу, а не увеличения.</p><h1 class='small-topic-2'>Функции с возвращаемыми значениями</h1><p class='simple-text'>До сих пор мы использовали только переменные, которые так или иначе зависели только от номера вызова функции loop, т.е. так или иначе зависящие от времени, прошедшего с момента старта Arduino.</p><p class='simple-text'>Это интересно, но не даёт таких возможностей к написанию программ, как получение значений из-вне. Допустим, к Arduino подключён какой-то сенсор: датчик освещённости, датчик газа, простой потенциометр или что-то ещё. Как получить его показания и использовать их в программе для чего-то полезного?</p><p class='simple-text'>Если говорить о сенсорах с аналоговым сигналом, для получения показаний с них существует встроенная функция analogRead. Давайте воспользуемся ей, чтобы сделать программу для устройства, которое изменяет яркость свечения светодиода, подключённого к 5-му пину в зависимости от поворота ручки потенциометра, подключённого к пину A0.</p><img src='img/n66.png' alt='sheme' class='sheme'><p class='simple-text'>Первое, что мы видим — это макроопределение пина с потенциометром:</p><img src='img/n67.png' alt='sheme' class='sheme'><p class='simple-text'>В качестве значения используется не просто число, а нечто с именем A0. Оно написано большими буквами, поэтому можно предположить, что это встроенное макроопределение. И это действительно так! A0 для Arduino Uno, например, определено как 14. Для других плат значение может быть другим. Мы не хотим помнить об этих тонкостях, поэтому просто использовали A0. Это всегда означает «нулевой аналоговый вход».</p><p class='simple-text'>Таким образом в качестве значения макроопределения мы использовали другое макроопределение. Так делать можно и это довольно распространённая практика.</p><p class='simple-text'>Теперь рассмотрим loop. В первой строке определяется переменная value, а в качестве значения ей присваивается значения выражения analogRead(POT_PIN). Но ведь это вызов функции, а не арифметическое выражение!</p><p class='simple-text'>Совершенно верно. Некоторые функции помимо того, что делают что-то полезное умеют так же возвращать значение обратно, в вызывающий код. Функции вроде pinMode или analogWrite не возвращают ничего, по задумке их автора, а вот analogRead возвращает некоторое целочисленное значение.</p><p class='simple-text'>Чтобы понять какие аргументы функция принимает, возвращает ли она что-нибудь и если возвращает, то что, следует обращаться к документации на эту функцию.</p><p class='simple-text'>Что касается analogRead, она принимает один аргумент: номер пина, с которого необходимо считать значение аналогового сигнала. А возвращает эта функция значение от 0 до 1023, где:</p><p class='simple-text'>Входное напряжение в 0 В возвращается как 0</p><p class='simple-text'>2 В возвращается как 409</p><p class='simple-text'>2,5 В возвращается как 512</p><p class='simple-text'>И так далее, до напряжения в 5 В, которому ставится в соответствие 1023</p><p class='simple-text'>Таким образом в первой строке loop мы просто считываем сигнал с потенциометра, получая угол поворота его ручки в виде целого числа в пределах от 0 до 1023.</p><p class='simple-text'>Как мы помним, функция analogWrite, которой мы пользуемся для управления яркостью светодиода ожидает целое число от 0 до 255 в качестве второго аргумента. Но у нас оказалась переменная с другим диапазоном. Что делать? Просто поделить значение на 4. Так наш диапазон будет смасштабирован до того, который подходит для analogWrite. </p><p class='simple-text'>Максимуму из одного диапазона равному 1023 станет соответствовать максимум из другого диапазона: 1023 / 4 = 255.</p><p class='simple-text'>Вспоминая о компактной записи, мы можем сделать наш loop чуть лаконичнее:</p><img src='img/n68.png' alt='sheme' class='sheme'><p class='simple-text pad-bot'>Итак, вы научились работать со сложными выражениями, макроопределениями и переменными. Использовать функции с возвращаемыми значениями и встраивать вычисления. Этих знаний уже достаточно для создания нехитрых устройств. Пробуйте, экспериментируйте, учитесь!</p></aside>"
    },
    {
        "title": "Логические выражения и ветвление",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Логические выражения и ветвление</h1><p class='simple-text'>Для работы с целыми числами в C/C++ существует тип переменных int. Но операции над целыми числами — не единственный инструмент в арсенале разработчика. Одними из важнейших элементов в программировании являются логические операции, выражения и типы данных.</p><p class='simple-text'>В то время как переменные типа int могут хранить произвольные целые числа, а операции над ними подчиняются законам целочисленной арифметики; логические переменные могут хранить лишь одно из двух значений: истину или ложь, а операции над ними подчиняются законам алгебры логики.</p><p class='simple-text'>Алгебра логики — умное название для интуитивно понятных вещей: операций «и», «или», «не» над высказываниями, которые либо справедливы, либо нет. Например, рассмотрим такое логическое выражение: «в коридоре темно и по коридору идёт человек». Оно состоит из двух логических значений (утверждения про темноту и человека) и одного оператора (союз «и»). Его итоговым значением также будет логическое значение, которое можно использовать, скажем, как сигнал для включения света в коридоре гостиницы.</p><p class='simple-text'>В программировании переменные, которые хранят логические значения называются булевыми переменными, а операторы, которые производят над ними действия называют булевыми операторами или просто логическими операторами.</p><h1 class='small-topic-2'>Логические операции в C++</h1><p class='simple-text'>В C++ для булевых переменных существует тип bool. Для обозначения истины в C++ используется слово true, а для обозначения лжи — слово false. Таким образом, если для объявления целочисленных переменных мы используем:</p><img src='img/n69.png' alt='sheme' class='sheme'><p class='simple-text'>Для логических переменных, используется:</p><img src='img/n70.png' alt='sheme' class='sheme'><p class='simple-text'>Поскольку C++ для Arduino — это некоторая надстройка над голым C++, для обозначения логического типа наряду с bool существует ещё слово boolean. Это абсолютные синонимы. Можете использовать и то и другое. Просто из соображений единого стиля и повышения читаемости кода выберите один из терминов и используйте его всюду. Мы в статье будем использовать bool, просто потому что в нём меньше букв и он входит в стандарт языка.</p><p class='simple-text'>Применение на практике: экологичный отель</p><p class='simple-text'>Давайте разовьём тему с энергосберегающим освещением и сделаем на Arduino устройство, которое включает свет в коридоре только тогда, когда это действительно необходимо.</p><p class='simple-text'>Допустим, к Arduino подключён аналоговый датчик уровня освещённости, пироэлектрический цифровой датчик движения тёплых объектов и экологичная светодиодная лампа.</p><p class='simple-text'>Тогда скетч будет выглядеть следующим образом:</p><img src='img/n71.png' alt='sheme' class='sheme'><p class='simple-text'>Взглянем на loop и поймём что здесь происходит. С первой строкой всё понятно: мы считываем значение освещённости с аналогового сенсора с помощью встроенной функции analogRead и присваиваем его переменной с именем lightLevel.</p><p class='simple-text'>Далее мы объявляем логическую переменную motionDetected в качестве значения которой присваиваем результат вызова встроенной функции digitalRead. Функция digitalRead похожа по своей сути на analogRead, но может возвращать лишь одно из двух значений: либо истину (true), либо ложь (false). То есть это функция, которая возвращает логическое значение. Она подходит для считывания показаний разнообразных бинарных цифровых датчиков. В нашем примере мы как раз использовали такой: пироэлектрический сенсор, который выдаёт 0 вольт, пока движения в его радиусе видимости нет и 5 вольт, когда замечено перемещение тёплого объекта: человека, кошки или кого-то ещё. Нулю вольт микроконтроллер ставит в соответствие значение false, а пяти вольтам — true.</p><p class='simple-text'>Итак, по итогам исполнения второй строки, в переменной motionDetected будет храниться либо истина, либо ложь в зависимости от того замечено ли движение в коридоре.</p><p class='simple-text'>Далее мы видим определение булевой переменной tooDark, которой в качестве значения присваивается значение выражения lightLevel < LIGHT_LEVEL_THRESHOLD. Символ <, как можно догадаться, в C++ означает оператор «меньше, чем». Из двух численных операндов, этот оператор делает один логический результат. Значение всего выражения считается истинным, если то, что записано слева от знака (lightLevel в нашем случае) меньше, чем то, что записано справа от знака (LIGHT_LEVEL_THRESHOLD). Довольно логично и интуитивно понятно, не правда ли?!</p><p class='simple-text'>Таким образом в переменной tooDark окажется значение true, только если значение уровня освещённости lightLevel, полученное ранее, окажется меньше 600. В противном случае, в переменной окажется false.</p><p class='simple-text'>Конкретное значение, вроде 600 в нашем случае, в подобных случаях часто получают экспериментально: в зависимости от используемого сенсора и конфигурации помещения, где стоит устройство.</p><p class='simple-text'>Идём дальше. Мы видим объявление булевой переменной lightningRequired, в качестве значения которой присваивается значение выражения tooDark && motionDetected. Символ && в C++ означает оператор логического «и». Как можно догадаться, всё выражение считается истинным тогда и только тогда, когда и то, что справа, и то что слева от оператора истинно. Таким образом, переменная lightningRequired примет значение true, если в коридоре одновременно: и слишком темно, и замечено движение человека. Если не выполнено хоть одно из условий, результатом будет false. Как раз то, что нужно.</p><p class='simple-text'>И наконец, последним выражением идёт вызов функции digitalWrite для пина Arduino, к которому подключена лампа. Нам нужно включить лампу, если переменная lightningRequired содержит истинное значение и выключить, если в ней хранится ложь. Чтобы сделать это, мы используем тернарный условный оператор ? :. Где в качестве условия используем просто значение переменной lightningRequired. Помните? В тернарном операторе условие считается выполненным, если его значение — не ноль; и не выполненным если его значение — ноль.</p><p class='simple-text'>На самом деле для процессора не существует понятия логических значений. Всё что он умеет — оперировать над целыми числами. Поэтому в C++ существует автоматическое преобразование типов. Там, где ожидается int, а мы используем bool, за кадром происходит автоматическое преобразование: true превращается в целое число 1, а false — в целое число 0.</p><p class='simple-text'>Так что, булевы выражения и переменные — ни что иное, как удобство для программистов, синтаксический сахар, который позволяет писать программы более понятно и выразительно.</p><p class='simple-text'>Возвращаясь к нашему примеру, в выражении:</p><img src='img/n72.png' alt='sheme' class='sheme'><p class='simple-text'>второй аргумент примет значение HIGH, если lightningRequired — это true; и LOW, если lightningRequired — это false. Таким образом, мы добились чего хотели: включения света, если он нужен и выключения, если он не уместен.</p><p class='simple-text'>О краткости записи</p><p class='simple-text'>Если вспомнить об автоматическом преобразовании переменных разных типов, а ещё о том, что HIGH — это ничто иное, как макроопределение числа 1, а LOW — макроопределение числа 0, последнюю строку в нашем примере можно сократить до лаконичного выражения:</p><img src='img/n73.png' alt='sheme' class='sheme'><p class='simple-text'>Мы обошлись без тернарного оператора: ведь всё равно функция digitalWrite получит:</p><p class='simple-text'>единицу: то же самое, что и HIGH, если lightningRequired будет true</p><p class='simple-text'>ноль: то же самое, что и LOW, если lightningRequired будет false</p><p class='simple-text'>Кроме того, логические выражения — это самые обычные выражения в C++, к которым применяются общие правила встраивания. Поэтому весь код loop в примере с экологичным освещением на самом деле мог бы быть записан в одну строку:</p><img src='img/n74.png' alt='sheme' class='sheme'><p class='simple-text'>Да, код теперь находится на грани читаемости, но это всего лишь демонстрация возможностей. В реальной жизни лучше использовать пару промежуточных переменных:</p><img src='img/n75.png' alt='sheme' class='sheme'><p class='simple-text'>Или хотя бы использовать перенос строк для наглядности:</p><img src='img/n76.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>А если свет таки нужен: условное выражение if</h1><p class='simple-text'>Внимательный читатель мог заметить, что приведённый скетч едва ли может работать в реальных условиях. Если мы включим свет, когда слишком темно и зафиксировано движение, при следующем же прогоне loop датчик «увидит» свет от нашей же лампы, программа посчитает, что и так достаточно светло и выключит лампу. Процесс постоянного выключения и включения так и будет продолжаться пока пироэлектрический датчик будет фиксировать движение. В лучшем случае мы получим свечение лампы в пол силы, в худшем — раздражающее мерцание. Как быть?</p><p class='simple-text'>Можно после включения лампы усыплять программу на, скажем, 30 секунд. Вполне достаточно, чтобы дать постояльцу отеля пройти коридор и не так уж расточительно с точки зрения экономии электроэнергии.</p><p class='simple-text'>Как сделать так, чтобы задержка на 30 секунд производилась только после включения лампы, но не после выключения? Для этого в C++ существует условное выражение «if». Используя его, скетч может выглядеть следующим образом:</p><img src='img/n77.png' alt='sheme' class='sheme'><p class='simple-text'>Начало программы прежнее, но в loop появляется новое составное выражение, обозначаемое словами if, else и фигурными скобками. Давайте поймём в чём его суть.</p><p class='simple-text'>Сразу после слова if компилятор C++ ожидает в круглых скобках увидеть логическое выражение, которое в этом случае называется условием. Оно имеет тот же смысл, что и для тернарного оператора. Если его значение — не ноль или истинно, выполняется блок кода, который следует сразу после условия в фигурных скобках. В нашем случае, если tooDark и motionDetected истины, будет выполнен блок кода из двух строк:</p><img src='img/n78.png' alt='sheme' class='sheme'><p class='simple-text'>Если же условие было нулём, или что то же самое — ложно, блок кода следующий за условием пропускается и не выполняется вовсе. Зато, если после после этого пропущенного блока следует слово else, выполняется блок кода в фигурных скобках, следующий после этого слова. В нашем случае, если либо tooDark, либо motionDetected были false, выполнится блок кода из одной строки:</p><img src='img/n79.png' alt='sheme' class='sheme'><p class='simple-text'>Стоит отметить, что в случае выполнения условия, блок кода следующий после else не выполняется, а пропускается. То есть, на самом деле, выражение if — это отображение в языке программирования простого и понятного утверждения: «если что-то, делай то-то, а иначе делай сё-то».</p><p class='simple-text'>Возвращаясь к нашему примеру, код можно интерпретировать так: «если требуется освещение, включить свет и уснуть на 30 секунд, а если свет не нужен — выключить его». Довольно просто и логично.</p><p class='simple-text'>Использование выражений, которые меняют ход программы в зависимости от каких-то условий называется ветвлением программы, а блоки кода после if и else называются ветками.</p><p class='simple-text'>Краткая версия if</p><p class='simple-text'>При использовании выражения if совершенно не обязательно использовать ветку else. Если что-то должно произойти при выполнении условия, а при невыполнении не должно происходить ничего, ветку else можно просто опустить. Например, мы можем изменить loop нашей программы следующим образом:</p><img src='img/n80.png' alt='sheme' class='sheme'><p class='simple-text'>Эта вариация кода делает абсолютно то же, что и раньше. Просто теперь код организован иначе. Мы в любом случае делаем указание лампе на включение или выключение, вызывая digitalWrite с булевым значением lightningRequired, но засыпаем на 30 секунд только если мы включаем свет, т.е. если переменная lightningRequired истинна. Если мы только что выключали свет, спать не нужно: нужно пропустить delay и сразу оказаться в конце функции loop. Поэтому мы не писали ветку else вовсе.</p><p class='simple-text'>Более того, если в блоке кода после if или else содержится всего одно выражение, фигурные скобки можно не писать:</p><img src='img/n81.png' alt='sheme' class='sheme'><p class='simple-text'>Вложенные выражения if</p><p class='simple-text'>Блоки кода, используемые в условных выражениях — это самые обычные блоки, которые следуют общим правилам C++. Поэтому в ветку одного if можно запросто вкладывать другой if.</p><p class='simple-text'>Для примера рассмотрим скетч устройства, которое контролирует открывание двери холодильника, автомобиля или чего-то такого. Мы хотим, чтобы при открытии двери включалась подсветка, а если дверь остаётся открытой более 20 секунд, раздавался бы предупреждающий писк. При этом, хочется, чтобы писк можно было отключить переключателем, на случай когда производится длительная загрузка/разгрузка: так он не будет нервировать.</p><p class='simple-text'>Допустим на дверце установлен постоянный магнит, а на раме бинарный цифровой датчик магнитного поля. Если магнитное поле фиксируется — дверца закрыта; иначе магнит отходит от датчика слишком далеко, магнитного поля нет — можно понять, что дверца открыта. Также мы подключим к Arduino лампу подсветки, пьезо-пищалку (buzzer) и рокерный выключатель.</p><p class='simple-text'>В этом случае код работающего устройства может выглядеть так:</p><img src='img/n82.png' alt='sheme' class='sheme'><p class='simple-text'>Давайте разберём происходящее в loop. Первым делом мы определяем переменную doorOpened и присваиваем ей значение выражения !digitalRead(DOOR_SENSOR_PIN). Как уже говорилось, дверь стоит считать открытой, если магнитного поля нет, т.е. digitalRead для нашего сенсора возвращает false. Символ ! перед логическим выражением в C++ означает оператор логического «не» или просто оператор отрицания. Он действует на значение, записанное после него, и из true делает false, а из false делает true. Как раз то, что нам нужно в этом случае.</p><p class='simple-text'>Далее следует выражение if, проверяющее открыта ли дверь. Если да, начинается исполнение блока кода, следующего непосредственно за условием. В нём мы первым делом включаем подсветку. Затем засыпаем на 20 секунд (20×1000 мс).</p><p class='simple-text'>Далее мы должны включить пищалку если только она не была умышленно выключена. Для этого мы проверяем состояние переключателя, который за это отвечает. Мы объявляем переменную buzzEnabled, которой присваиваем логическое значение, считанное с выключателя.</p><p class='simple-text'>Обратите внимание, переменная buzzEnabled объявлена прямо внутри блока кода, следующего за if. Так делать можно и нужно: хорошей практикой является объявление переменных как можно ближе к тому месту, где они впервые используются.</p><p class='simple-text'>Напомним о понятии области видимости переменных: переменные доступны для использования только внутри того блока, где они объявлены. В нашем случае buzzEnabled может быть использована в выражениях внутри блока кода, следующего за if (doorOpened), но попытка обращения к ней откуда-то ещё: например, из блока кода ветки else или непосредственно в loop вне ветки if, приведёт к ошибке на этапе компиляции программы. И это хорошо: нам не стоит впутывать переменную, которая нужна сию секунду в другие происходящие процессы; это делает программу чище и нагляднее.</p><p class='simple-text'>Вслед за чтением переключателя следует вложенное условное выражение. Его суть абсолютно та же, что и ранее: в зависимости от условия выполнить или не выполнить код. Одно лишь отличие: оно расположено прямо в блоке кода ветки другого if. Это распространённая практика, которая встречается в программировании довольно часто. На самом деле, во вложенный if можно вкладывать другие if, в них ещё одни и т.д. до бесконечности: язык C++ вас в этом не ограничивает.</p><p class='simple-text'>Возвращаясь к примеру, если переключатель находится в положении «включён», т.е. buzzEnabled содержит true, мы включаем писк. Это делается с помощью встроенной функции tone. Она принимает 2 аргумента: номер пина Arduino, куда подключён пьезоизлучатель и частоту писка. В данном случае, мы выбрали частоту 4000 Гц, т.е. 4 КГц.</p><p class='simple-text'>Наконец, если дверь была закрыта, т.е. doorOpened содержит ложь, мы убеждаемся, что подсветка и пищалка выключены. Это делается в ветке else первого условия if. Как выключить лампу вы понимаете, а функция noTone, как можно догадаться, отключает писк на указанном пине.</p><p class='simple-text'>Вспоминая о правилах короткой записи и встраивании выражений, мы можем чуть упростить код loop. Он может выглядеть так:</p><img src='img/n83.png' alt='sheme' class='sheme'><p class='simple-text'>Мы убрали фигурные скобки для внутреннего if и встроили вызовы digitalRead прямо в условные выражения.</p><p class='simple-text'>Обратите внимание, как правильное использование отступов в блоках кода, помогает легко понять к какому if относится else и что за чем и при каких условиях следует. Никогда не пишите без отступов несмотря на то, что компилятору всё равно. Это делает код не читаемым и для других людей, и для вас самих:</p><img src='img/n84.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Клики кнопок</h1><p class='simple-text'>Одной из типичных задач при создании устройств на микроконтроллерах является определение момента клика тактовой кнопки, чтобы на это можно было как-то отреагировать. Проблема в том, что кнопка, как сенсор, может лишь сообщить зажата ли она сейчас или отпущена. Она не может сообщить, что была «нажата только что».</p><p class='simple-text'>Но эта проблема легко решается с помощью небольшого приёма в программной части проекта. Давайте сделаем примитивное устройство с лампой и кнопкой, которое бы включало и выключало лампу, поочерёдно, при нажатии кнопки: клик — включили, клик — выключили:</p><img src='img/n85.png' alt='sheme' class='sheme'><p class='simple-text'>В скетче мы можем видеть 2 булевы переменные:</p><p class='simple-text'>lampState содержит true, если лампа должна быть сейчас включена и false в противном случае</p><p class='simple-text'>wasButtonDown хранит состояние кнопки на момент последнего прогона loop: если кнопка была зажата, значением будет true</p><p class='simple-text'>Теперь взглянем на сам loop. Первым делом мы считываем состояние кнопки в логическую переменную isButtonDown. Если кнопка зажата isButtonDown будет содержать true.</p><p class='simple-text'>Далее следует условное выражение if с проверкой условия, суть которого в том, чтобы понять была ли нажата кнопка только что, или она зажата уже давно. Для этого и используется значение wasButtonDown.</p><p class='simple-text'>Таким образом, условие стоит воспринимать как «кнопка зажата сейчас и не была зажата ранее». Это и есть условие сиемоментного «клика» кнопкой.</p><p class='simple-text'>Если условие клика выполнено — действуем. Переворачиваем значение lampState с ног на голову:</p><img src='img/n86.png' alt='sheme' class='sheme'><p class='simple-text'>Далее, в ветке if следует delay(10). Вызов delay здесь сделан исключительно из-за несовершенства механических кнопок. При нажатии, за микросекунды, когда соприкасаются пластины, кнопка может зафиксировать замыкание и размыкание десятки раз. Добавив delay(10) мы просто пережидаем шторм. Десять миллисекунд — более чем достаточно для успокоения кнопки, но достаточно мало, чтобы человек заметил это.</p><p class='simple-text'>Далее мы присваиваем переменной wasButtonDown недавно считанное значение isButtonDown, говорящее о том нажата ли кнопка сейчас. Если кнопка была зажата только что, произойдёт переключение состояния лампы lampState, а переменная wasButtonDown в итоге примет значение true и будет оставаться с ним пока кнопку не отпустят. Таким образом, при следующем вызове loop состояние не будет изменено снова.</p><p class='simple-text'>Если бы мы не прибегали к этому трюку, а использовали только текущее состояние кнопки без оглядки на предысторию, состояния бы менялись пока кнопка зажата, десятки тысяч раз в секунду. С точки зрения человека это выглядело бы как явная, назойливая проблема с устройством.</p><h1 class='small-topic-2'>Цепочки if</h1><p class='simple-text'>Напоследок давайте запрограммируем устройство, которое является простым климат-контролем для, например, террариума. Допустим к Arduino подключён термистор, кондиционер, обогреватель и зелёный светодиод. Если получаемая температура слишком высокая, мы должны включать кондиционер, если слишком низкая — обогреватель, а если в пределах нормы — включать светодиод.</p><p class='simple-text'>Тогда программа может выглядеть так:</p><img src='img/n87.png' alt='sheme' class='sheme'> <p class='simple-text'>В этой программе всё должно быть знакомым. Вопрос может вызвать лишь использование else и if рядом, на одной строке. На самом деле — это всего лишь иной способ записать несколько вложенных условных выражений. Мы могли бы написать то же самое таким образом:</p><img src='img/n88.png' alt='sheme' class='sheme'><p class='simple-text'>Но вспомним, что условное выражение — это полноправное выражение в C++. В внешней ветке else оно одно, поэтому фигурные скобки можно опустить:</p><img src='img/n89.png' alt='sheme' class='sheme'><p class='simple-text'>А вспомнив о том, что пустое пространство для компилятора ничего не значит, можем убрать несколько отступов и перенос строки, чтобы получить:</p><img src='img/n90.png' alt='sheme' class='sheme'><p class='simple-text'>Подобные цепочки из выражений if — довольно частое явление. Если бы вариантов было больше трёх, вложенные if смотрелись бы громоздко и уродливо, в то время как такая цепочка выглядела бы всё равно понятно и хорошо.</p><p class='simple-text'>На самом деле, программу климат-контроля можно написать компактнее. В этом виде она приведена просто для демонстрации if - else if - else цепочки. Для полноты картины приведём краткую версию:</p><img src='img/n91.png' alt='sheme' class='sheme'><p class='simple-text'>Опять же, всё знакомо за исключением, быть может значения выражения !(tooCold || tooHot). Символ || в C++ — это оператор логического «или». Значение выражения истинно если хотя бы одно из значений: слева или справа от оператора истинны.</p><p class='simple-text'>Логические выражения — ни что иное, как арифметические выражения. Здесь действуют всё те же правила: в одном выражении может быть сколько угодно операторов, а очерёдность их применения можно обозначить скобками. В данном случае, мы сначала вычисляем логическое значение tooCold || tooHot, а затем оператором логического «не» (!) инвертируем полученное значение.</p><p class='simple-text pad-bot'>Итак, вы познакомились с логическими переменными, выражениями и сопутствующими операторами. Это уже позволяет делать устройства, которые выглядят умными. Включайте фантазию, дерзайте!</p></aside> "
    },
    {
        "title": "Конечные автоматы, перечисления, выражения switch",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Конечные автоматы, перечисления, выражения switch</h1><p class='simple-text'>Часто бывает так, что программа должна вести себя по-разному в зависимости от наступления каких-то событий, от времени прошедшего с начала работы и т.д.</p><p class='simple-text'>Например, давайте рассмотрим устройство, подобие гирлянды. Допустим мы хотим, чтобы к Arduino были подключены светодиоды, режим свечения которых можно было бы менять нажатием кнопки. Режима может быть три:</p><p class='simple-text'>1.Светодиоды горят постоянно</p><p class='simple-text'>2.Светодиоды то выключаются, то включаются каждые 2 секунды</p><p class='simple-text'>3.Светодиоды плавно набирают яркость от нуля до максимума за 10 секунд, гаснут и начинают набирать яркость заново</p><p class='simple-text'>Нажимая кнопку, мы хотим переходить к очередному режиму: 1 → 2, 2 → 3, 3 → 1. Собственно точно так же, как это происходит во многих ёлочных гирляндах.</p><p class='simple-text'>Мы не будем заниматься управлением каждым светодиодом в отдельности. Просто предположим, что все они сразу подключены к одному из пинов Arduino через MOSFET-транзистор или другой коммутатор. К какому-то другому пину при этом подключена тактовая кнопка для смены режима.</p><p class='simple-text'>При таком раскладе, скетч, делающий всю работу, может выглядеть так:</p><img src='img/t1.png' alt='sheme' class='sheme'><p class='simple-text'>Получилась не самая простая программа. Но и логики у нас предостаточно. Шаг за шагом разберёмся что здесь написано. Начнём с некоторых макроопределений.</p><h1 class='small-topic-2'>Состояния</h1><p class='simple-text'>Как уже говорилось, у нас есть 3 режима: постоянное свечение, мигание, нарастание яркости. Но как их обозначать, чтобы сказать процессору какой из них текущий, какой следующий и т.п.? Как мы уже знаем, всё, с чем работает процессор — целые числа. Зная это, мы можем все возможные режимы просто пронумеровать:</p><p class='simple-text'>0 — режим постоянного свечение, мы назвали его именем STATE_SHINE</p><p class='simple-text'>1 — режим мигания, мы назвали его STATE_BLINK</p><p class='simple-text'>2 — режим нарастания яркости, мы назвали его STATE_FADE</p><p class='simple-text'>Использование общего префикса в названиях, конечно, не обязательно — это всего-навсего макроопределения — но для группировки связанных по смыслу значений префиксы довольно удобны и встретить их можно довольно часто.</p><p class='simple-text'>В каждом режиме наше устройство делает что-то уникальное, отличное от того, что происходит в других режимах. Текущим может быть лишь один режим. А возможные переходы чётко определены: каждый следующий включается при нажатии кнопки. Такие системы называются конечными автоматами, а их режимы называются состояниями (англ. state).</p><p class='simple-text'>Если говорить формально, конечный автомат — это система с конечным, известным количеством состояний, условия переходов между которыми фиксированы и известны, а текущим всегда является ровно одно состояние.</p><p class='simple-text'>Что ж, мы делаем конечный автомат — отлично. Текущее состояние, т.е. режим свечения будем хранить в переменной с именем ledState, которую изначально установим в значение STATE_SHINE. Таким образом, при включении Arduino система будет находиться в режиме постоянного свечения.</p><p class='simple-text'>О предназначении других макроопределений и переменных поговорим по ходу дела.</p><h1 class='small-topic-2'>Цепочка переходов между состояниями</h1><p class='simple-text'>Разберём функцию loop. А точнее, её первую часть и те определения, которые её касаются:</p><img src='img/t2.png' alt='sheme' class='sheme'><p class='simple-text'>Первым делом мы считываем состояние кнопки в логическую переменную isButtonDown. А сразу после этого проверяем условие того, что она была нажата только что, а не находится в этом состоянии с предыдущего вызова loop. Вы могли узнать типичный приём для определения клика кнопки. Это он и есть, поэтому вызов delay и назначение wasButtonDown в конце должны быть вам понятны. Сосредоточимся на происходящем внутри условного выражения if.</p><p class='simple-text'>Оператор равенства</p><p class='simple-text'>В блоке кода if мы видим ещё одно, вложенное условное выражение оформленное цепочкой.</p><img src='img/t3.png' alt='sheme' class='sheme'><p class='simple-text'>Его суть в том, чтобы установить вместо текущего состояния следующее. С помощью условий определяется текущее состояние, а в коде веткок устанавливается соответствующее следующее состояние.</p><p class='simple-text'>Обратите внимание, что в C++ проверка на равенство осуществляется символом ==, т.е. двойным знаком равенства. Так записывается оператор «равно». Значение логического выражения будет истинным, если значения слева и справа от == равны.</p><p class='simple-text'>Типичная ошибка при программировании — перепутать оператор равенства == с оператором присваивания =. Если написать:</p><img src='img/t4.png' alt='sheme' class='sheme'><p class='simple-text'>программа будет абсолютно корректна с точки зрения компилятора C++, но происходить будет совсем не то, что предполагается: сначала переменной ledState будет присвоено значение STATE_SHINE, а только затем будет проверенно истинно ли её значение.</p><p class='simple-text'>Поэтому, например, в нашем случае, если бы мы допустили такую ошибку, при прохождении этого кода ledState всегда бы перезаписывалась значением STATE_SHINE, которое в свою очередь объявлено как 0, 0 в условии эквивалентен false, а следовательно внутрь блока кода мы бы никогда не попали.</p><p class='simple-text'>Итак, если рассматривать нашу цепочку из if в целом, можно видеть, что мы в условиях пытаемся понять какое состояние установлено сейчас и на основе этого, обновляем значение ledState, устанавливая его в следующий по нашей задумке режим.</p><h1 class='small-topic-2'>Своя логика в каждом состоянии</h1><p class='simple-text'>Мы сделали всё, что необходимо для того, чтобы по переменной ledState можно было понять, что именно нужно делать со светодиодами прямо сейчас. Осталось лишь реализовать эту логику на практике.</p><p class='simple-text'>Рассмотрим вторую половину кода функции loop и определения, которые в ней используются.</p><img src='img/t5.png' alt='sheme' class='sheme'><p class='simple-text'>В теле loop мы видим цепочку условных выражений, где в каждом из условий мы сравниваем текущее состояние ledState поочерёдно со всеми возможными. Суть точно та же, что и была ранее, при переключении состояний по нажатию кнопки: в зависимости от текущего значения ledState исполнить тот или иной блок кода.</p><p class='simple-text'>В приведённом коде можно отчётливо увидеть 3 блока кода: по одному на каждый режим свечения. Первый из них исполняется в случае, если ledState равно STATE_SHINE, т.е. если текущий режим — непрерывное свечение. Блок кода в этом случае примитивен, нам просто нужно убедиться, что светодиоды включены:</p><img src='img/t6.png' alt='sheme' class='sheme'><p class='simple-text'>Понятно, что проходя loop в следующий раз, процессор снова попадёт в эту ветку и ещё раз включит уже включённые светодиоды. Но в этом нет ничего страшного, это абсолютно нормальное явление, без побочных эффектов.</p><h1 class='small-topic-2'>Режим мигания</h1><p class='simple-text'>Дальше интереснее. Если текущее состояние было установлена в STATE_BLINK, т.е. режим мигания каждые 2 секунды, выполняется ветка с кодом:</p><img src='img/t7.png' alt='sheme' class='sheme'><p class='simple-text'>Вы знаете, что для того, чтобы просто помигать светодиодом на Arduino достаточно последовательно вызывать digitalWrite и delay, то включая, то выключая пин:</p><img src='img/t8.png' alt='sheme' class='sheme'><p class='simple-text'>Но мы поступили иначе и несколько сложнее. Зачем?</p><p class='simple-text'>Дело в том, что вызов delay приводит к усыплению процессора, и он просто «застывает» на вызове на указанный промежуток времени. Он не сможет заниматься ничем другим, кроме как спать. А теперь вспомним, что наша гирлянда всегда «одновременно» делает 2 вещи:</p><p class='simple-text'>1.	Управляет свечением светодиодов</p><p class='simple-text'>2.	Ловит момент нажатия кнопки, чтобы переключать режимы</p><p class='simple-text'>Таким образом, если в режиме мигания процессор заснёт на 2 секунды, а в этот промежуток времени мы кликнем кнопку переключения, её нажатие останется незамеченным и переход на следующий режим не произойдёт. А нам бы этого совершенно не хотелось.</p><p class='simple-text'>Как решить проблему? Не использовать delay вовсе! Вместо этого, мы каждый раз попадая в нашу ветку можем заново рассчитывать: должна ли гирлянда быть включена или выключена именно в текущий момент времени.</p><p class='simple-text'>Для этого мы используем небольшое арифметическое выражение: (millis() / BLINK_DELAY) % 2.</p><p class='simple-text'>Встроенная функция millis просто возвращает значение равное количеству милисекунд, прошедших с момента включения или перезагрузки Arduino. Мы используем целочисленное деление её результата на BLINK_DELAY, которое мы в свою очередь определили как 2000, т.е. 2000 миллисекунд.</p><p class='simple-text'>Таким образом значение millis() / BLINK_DELAY будет увеличиваться на единицу всякий раз, когда с момента старта Arduino пройдут очередные 2000 мс, т.е. 2 секунды.</p><p class='simple-text'>Далее мы просто берём остаток от деления на 2 этого промежуточного результата на. Таким образом, итоговое значение будет то 0, то 1, переключаясь каждые 2 секунды. То, что нам нужно! И мы просто передаём вычисленное значение в качестве аргумента при вызове digitalWrite:</p><img src='img/t9.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Режим нарастания яркости</h1><p class='simple-text'>Если текущее состояние нашей гирлянды — STATE_FADE, будет исполняться третий блок, который заставит светодиоды плавно набирать свою яркость в течение 10 секунд, гаснуть и набирать яркость снова:</p><img src='img/t10.png' alt='sheme' class='sheme'><p class='simple-text'>Суть примерно та же, что и для мигания. Просто мы используем немного другое выражение для расчётов и вызываем analogWrite вместо digitalWrite.</p><p class='simple-text'>Наша задача: заставить светодиоды набирать яркость от нуля до максимума ровно за 10 секунд или, что то же самое, 10000 миллисекунд. Функция analogWrite в качестве параметра яркости принимает значения от 0 до 255, т.е. всего 256 градаций. Поэтому, для увеличения яркости на одну градацию должно пройти 10000 мс ÷ 256 ≈ 39 мс. Именно эти значения мы определили в начале программы:</p><img src='img/t11.png' alt='sheme' class='sheme'><p class='simple-text'>Так значение выражения millis() / FADE_STEP_DELAY будет становиться на единицу больше каждый раз, когда проходит 39 мс.</p><p class='simple-text'>Обратите внимание на скобки в определении FADE_STEP_DELAY. Поскольку значения макроопределений подставляются в программу как есть, мы получаем millis() / (10000 / 256); а если скобок бы не было, получилось бы millis() / 10000 / 256, что совершенно не одно и то же с точки зрения математики. Поэтому добавляйте круглые скобки вокруг любых арифметических выражений, когда используете их в качестве значений макроопределений.</p><p class='simple-text'>Наконец, от промежуточного значения millis() / FADE_STEP_DELAY мы получаем остаток деления на 256. Таким образом, всё будет начинаться сначала всякий раз, когда промежуточное значение будет становиться кратным 256. То, что нужно!</p><h1 class='small-topic-2'>Арифметика состояний</h1><p class='simple-text'>Ещё раз взглянем на код, который обеспечивал нам включение очередного состояния при клике кнопки:</p><img src='img/t12.png' alt='sheme' class='sheme'><p class='simple-text'>Если бы состояний у нас было не 3, а 33, код бы растянулся на много строк, но при этом ничего нового и уникального в программу бы не добавлял: он бы оставался однотипным. Если вам при написании скетча кажется, что какие-то его места сводятся к монотонному набору инструкций, слабо отличающихся друг от друга, почти наверняка существует способ упростить этот код, сделать его проще, понятнее, компактнее. Стоит лишь подумать.</p><p class='simple-text'>Что можно сделать с нашей цепочкой? Вспомним, что состояния для процессора — это всего лишь целые числа. Мы определили их с помощью макроопределений.</p><img src='img/t13.png' alt='sheme' class='sheme'><p class='simple-text'>Эти числа мы определили последовательно. Поэтому переключение ledState на очередное значение — это ни что иное, как прибавление единицы. Единственная загвоздка — переход из последнего состояния в первое. Но нам уже знаком оператор остатка от деления, а с помощью него легко учесть этот сценарий. Тогда весь код для включения следующего состояния можно написать без всякого ветвления так:</p><img src='img/t14.png' alt='sheme' class='sheme'><p class='simple-text'>Где TOTAL_STATES — общее количество состояний, которое мы можем определить как:</p><img src='img/t15.png' alt='sheme' class='sheme'><p class='simple-text'>Перечисления enum</p><p class='simple-text'>Задача перечисления состояний и присвоение им последовательных целых значений довольно распространённая. Для подобных случаев, чтобы чуть упростить работу и повысить читаемость программы, в C++ существуют так называемые перечисления (англ. enumeration). Для объявления нового перечисления используется конструкция:</p><img src='img/t16.png' alt='sheme' class='sheme'><p class='simple-text'>С точки зрения компиляции это ничем не отличается от:</p><img src='img/t17.png' alt='sheme' class='sheme'><p class='simple-text'>Но в случае с enum нам не пришлось явно прописывать значения 0, 1, 2, 3 и т.д. В перечислениях, первая константа автоматически получает значение 0, а каждая следующая на единицу больше.</p><p class='simple-text'>И чем ещё хорошо перечисление: мы можем использовать его имя (State в нашем случае) в качестве типа данных, так же как int, bool и т.п. То есть мы можем определить переменную текущего состояния так:</p><img src='img/t18.png' alt='sheme' class='sheme'><p class='simple-text'>За кадром ledState осталась всё тем же целым числом, что и раньше, но сама программа теперь стала чуть понятнее и нагляднее: мы чётко обозначили, что собираемся хранить в нашей переменной.</p><p class='simple-text'>Собрав всё вместе, получим обновлённый вариант нашей программы:</p><img src='img/t19.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Выражение выбора switch</h1><p class='simple-text'>Для того, чтобы понять что делать со светодиодами гирлянды в данный конкретный момент мы использовали цепочку из выражений if, где поочерёдно сравнивали ledState со всеми возможными состояниями. Это довольно распространённый сценарий и для него в C++ существует выражение выбора switch. Мы можем использовать его для нашей цели:</p><img src='img/t20.png' alt='sheme' class='sheme'> <p class='simple-text'>Не сказать, что код стал компактнее, но он стал чуть нагляднее.</p><p class='simple-text'>Суть выражения switch такова. Сначала вычисляется значение арифметического выражения, записанного в круглых скобках. В нашем случае — это просто получение значения ledState. Затем, в блоке кода между фигурными скобками ищется метка case, чьё значение равно вычисленному. Исполнение кода начинается с неё и идёт последовательно до конца блока (не до следующего case). Исполнение блока можно завершить досрочно выражением break.</p><p class='simple-text'>Частая ошибка от невнимательности — забыть поставить break. В этом случае процессор выполнит код, принадлежащий другим меткам, а это чаще всего — не то, что нужно. Да, это неприятная особенность C++, но так уж сложилась история. Изначально это было сделано для того, чтобы можно было перечислить сразу несколько значений на одну ветку. Например, если бы для состояний STATE_FADE и STATE_BLINK мы, по задумке, должны бы были делать одно и то же, мы могли бы написать:</p><img src='img/t21.png' alt='sheme' class='sheme'><p class='simple-text'>Также в switch, на последнем месте можно указать метку со специальным именем default. Она будет выполнена, если ни одна другая метка case не подошла по значению.</p><img src='img/t22.png' alt='sheme' class='sheme'><p class='simple-text'>Итак, вы познакомились с конечными автоматами, состояниями, переходами, принципами одновременного выполнения нескольких задач. В нашем примере, для разных состояний мы использовали довольно простую логику: один вызов digitalWrite с нехитрым арифметическим выражением; а для переключения состояний и вовсе использовали последовательные переходы по клику кнопки. </p><p class='simple-text'>Ничто не мешает вам развить эту тему, чтобы сделать гораздо более умное устройство. Например, комнатный робот может иметь состояния патрулирования для обнаружения кота, состояние преследования кота, состояние индикации о низком уровне заряда батареи. Переключения будут происходить по сигналам с датчиков и уже не будут настолько прямолинейны. Логика самих состояний при этом может быть достаточно сложной: нужно получить значения с нескольких сенсоров, выбрать направление движения, покрутить моторами и т.п.</p><p class='simple-text'>Так же, как и со всем остальным, ничто не мешает делать вложенные конечные автоматы: то есть состояния, которые сами по себе являются конечными автоматами. Главное поддерживать код стройным и читаемым, тогда у вас всё получится!</p></aside>"
    },
    {
        "title": "Генераторы случайных чисел",
        "text": "<aside class='teory' id='scrollbar2'><h1 class='h1-another'>Генераторы случайных чисел</h1><p class='simple-text'>Если когда-нибудь пытались написать свой Тетрис, сделать электронную свечку или собрать светомузыку — точно использовали случайные числа. Пара строк кода и программа уже выдаёт новую фигурку или яркость светодиода. Всё просто?</p><p class='simple-text'>На самом деле нет. Компьютер штука умная, но предельно логичная. Выполнить сложную программу, обработать тысячи чисел за долю секунды — никаких проблем, но придумать действительно случайное число компьютер не может. Все «случайные» числа это результат выполнения заранее написанной программы. Поэтому правильнее называть их псевдослучайными.</p><h1 class='small-topic-2'>Стандартная функция генерации псевдослучайных чисел</h1><p class='simple-text'>В проектах на Arduino для получения псевдослучайного числа предусмотрена функция random(). В параметрах функции можно задать диапазон получаемых значений, от минимального до максимального.</p><img src='img/t23.png' alt='sheme' class='sheme'><p class='simple-text'>Если вы запустите этот скетч, увидите, что после каждого перезапуска платы последовательность чисел будет повторяться. Чтобы последовательность не повторялась, необходимо запустить генератор случайных чисел со случайным параметром. Для этого предусмотрена функция randomSeed(). В качестве параметра функции зададим номер свободного аналогового пина. Шум с него инициализирует генератор случайных чисел.</p><img src='img/t24.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Автомат для игры «Орёл и Решка»</h1><p class='simple-text'>Это самый простой игровой автомат. Arduino Uno, пара светодиодов и тактовая кнопка. Нажимаете кнопку — случайным образом загорается один из светодиодов: или красный, или зелёный. Угадали какой загорится, можно подавать заявку на участие в «Битве экстрасенсов».</p><img src='img/t25.png' alt='sheme' class='sheme'><p class='simple-text'>В проекте использовались:</p><p class='simple-text'>Arduino Uno</p><p class='simple-text'>Slot Shield</p><p class='simple-text'>Индикаторные светодиоды</p><p class='simple-text'>Тактовая кнопка</p><img src='img/t26.png' alt='sheme' class='sheme'><h1 class='small-topic-2'>Автомат «Три семёрки»</h1><p class='simple-text'>Игровой автомат генерирует трёхзначное число. Если всецифры в нём совпали — Bingo! Если нет, попробуйте свою удачу ещё раз.</p><img src='img/t27.png' alt='sheme' class='sheme'><p class='simple-text'>В проекте использовались:</p><p class='simple-text'>Arduino Uno</p><p class='simple-text'>Slot Shield</p><p class='simple-text'>Тактовая кнопка</p><p class='simple-text'>четырёхразрядный дисплей Quad Display</p><img src='img/t28.png' alt='sheme' class='sheme'></aside>"
    }
]
